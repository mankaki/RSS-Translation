<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title><![CDATA[Apple News, Rumors, Reviews, Prices & Deals | AppleInsider]]></title><link/> https://appleinsider.com<atom:link href="https://rsshub.app/appleinsider" rel="self" type="application/rss+xml"></atom:link><description><![CDATA[Apple News, Rumors, Reviews, Prices & Deals | AppleInsider - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]></description><generator> RS集线器</generator><webmaster>i@diygod.me (DIYgod)</webmaster><language> zh-cn</language><lastbuilddate> 2023 年 8 月 7 日星期一 15:46:39 GMT</lastbuilddate><ttl> 120 </ttl><item><title><![CDATA[TSMC concerned over labor shortages for new plant in Germany]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>台积电老板<a href="https://appleinsider.com/articles/23/07/20/tsmc-delays-arizona-plant-blames-us-labor-shortage">此前曾将其在亚利桑那州工厂开业的延迟归咎于</a>缺乏合格劳动力，而那里的劳动力则抱怨<a href="https://appleinsider.com/articles/23/07/14/arizona-workers-accuse-tsmc-of-fatalities-at-dangerous-construction-site">工作条件危险</a>。</p></div><div class="col-sm-12"><p>据<em>英国《金融时报》</em>报道，至少劳动力短缺的故事即将在德国<a href="https://www.ft.com/content/8cb93bc0-d560-45e8-8fd3-ffd9b95cbba0">重演</a>。台积电此前一直<a href="https://appleinsider.com/articles/21/12/12/tsmc-talks-to-germany-about-potential-new-chip-plant">在与德国政府就开设工厂进行谈判</a>，目前预计将在秋季宣布交易。</p></div><div class="col-sm-12"><p>不过，<em>英国《金融时报》</em>称，台积电可能会在萨克森州建厂，萨克森州是德国的一个地区，其中包括德累斯顿市。该城市及其周边地区已经支持了大约七家芯片制造厂。</p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><div class="col-sm-12"><p> 台积电在德国无论走到哪里，情况都没有太大不同。包括规划中的英特尔工厂在内，该国拥有近20家晶圆厂。这是合格劳动力短缺的原因之一。</p></div><div class="col-sm-12"><p>然而，还有一个事实是，据估计，超过五分之一的德国电气工程师和三分之一的工程主管将在未来 10 至 12 年内退休。</p></div><div class="col-sm-12"><p>台积电董事长刘马克 (Mark Liu) 在 2023 年 6 月的投资者会议上表示：“那里确实存在差距。”</p></div><div class="col-sm-12"><p>作为回应，德国政府通过了一项法律，使外国工人更容易移居德国。台积电也有可能至少尝试将许多工厂从台湾基地转移到中国，就像它<a href="https://appleinsider.com/articles/23/08/07/lawmakers-urged-to-block-tsmc-worker-visas-over-arizona-plant-construction">在美国</a>所做的那样。</p></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 15:14:01 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/tsmc-concerned-over-labor-shortages-for-new-plant-in-germany</guid><link/> https://appleinsider.com/articles/23/08/07/tsmc-concerned-over-labor-shortages-for-new-plant-in-germany <author><![CDATA[William Gallagher]]></author></item><item><title><![CDATA[Lawmakers urged to block TSMC worker visas over Arizona plant construction]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>台积电亚利桑那州工厂已被<a href="https://appleinsider.com/articles/23/07/20/tsmc-delays-arizona-plant-blames-us-labor-shortage">推迟至 2025 年</a>，原因是该工厂无法找到足够的技术工人来按时开业。为了迎头赶上，台积电今年 6 月表示，将把台湾<a href="https://appleinsider.com/articles/23/06/29/tsmc-sends-more-taiwanese-workers-to-finish-arizona-plant">员工</a>带到美国在该工厂工作。</p></div><div class="col-sm-12"><p>然而，一项运动根本不希望工人进入该国在工厂工作，台积电应该使用美国工人。</p></div><div class="col-sm-12"><p>这项名为“与美国工人站在一起”<a href="https://protectazworkers.org/">的运动</a>敦促居民联系当地国会领导人，阻止台积电外国工人签证，并迫使这家芯片制造商使用来自亚利桑那州的工人。</p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><div class="col-sm-12"><p> 该运动援引政界人士的保证，称台积电工厂的工作将主要由亚利桑那州工人进行，包括由 CHIP 法案资助的后期阶段，认为台积电的工人进口公告表明“完全无视美国劳工和 CHIP 的原则”行为。</p></div><div class="col-sm-12"><p> “与美国工人站在一起”活动和网站由 Revitalize Arizona 资助，主要资金来自 Residents for Accountability 和 Arizona Pipe Trades 469。</p></div><div class="col-sm-12"><p> Arizona Pipe Trades 469 还<a href="https://www.votervoice.net/AZPipeTrades/Campaigns/106830/Respond">单独致电</a>联系立法者，再次敦促阻止 EB-2 工人签证。请愿书向代表人民的代表发送了一封格式信函，其中声称台积电“将利润置于工人安全之上”，并且“故意歪曲亚利桑那州劳动力的素质、技能和经验”。</p></div><div class="col-sm-12"><p>虽然这些活动涉及设施建设，但台积电表示，工人的涌入并不会取代该工厂目前 12,000 名员工中的任何一个，也不会改变美国的招聘计划。</p></div><div class="col-sm-12"><p> 2月份的一份报告称，台积电<a href="https://appleinsider.com/articles/23/02/22/tsmc-managers-think-americans-dont-work-hard-enough">员工对使用美国工人进行施工的计划感到不满</a>，称美国工程师质疑这种做法，而台湾工程师据称习惯了长时间工作和周末工作。</p></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 14:56:03 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/lawmakers-urged-to-block-tsmc-worker-visas-over-arizona-plant-construction</guid><link/> https://appleinsider.com/articles/23/08/07/lawmakers-urged-to-block-tsmc-worker-visas-over-arizona-plant-construction <author><![CDATA[Malcolm Owen]]></author></item><item><title><![CDATA[Daily deals: $200 off 15" MacBook Air, Apple Watch from $137, Office for Mac $40, more]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p> <em>AppleInsider</em>团队在互联网上搜寻在线商店的一流特价商品，展示一系列热门科技产品的无与伦比的优惠，包括<a href="https://appleinsider.com/deals">Apple 产品、电视、配件和其他小玩意的折扣</a>。我们每天都会发布我们的热门发现，以帮助您将更多现金放回钱包。 </p></div><div class="col-sm-12"><h2 data-anchor="top-deals-for-august-7" id="top-deals-for-august-7"> 8 月 7 日最热门优惠</h2></div><div class="col-sm-12"><ul><li><a href="https://www.bhphotovideo.com/c/product/1770977-REG/apple_mba15m2mn_11_15_macbook_air_midnight.html/BI/1717/KBID/2301/SID/dd---" rel="sponsored" target="_blank">B&amp;H 15 英寸 MacBook Air Midnight、24GB RAM、2TB SSD（节省 200 美元）现价 2,299 美元</a></li><li><a href="https://www.tkqlhce.com/click-1989299-13142105?sid=dd---&amp;url=https%3A%2F%2Fsellout.woot.com%2Foffers%2Fapple-watch-series-6-open-box-24" rel="sponsored" target="_blank">Woot Apple Watch Series 6 售价 159.99 美元至 223.09 美元</a></li><li>2 件装 FireNova iPhone 13 Pro 保护壳（原价 24.99 美元，44% 折扣） <a href="https://www.dpbolvw.net/click-1989299-13142105?sid=dd---&amp;url=https%3A%2F%2Fsellout.woot.com%2Foffers%2Fiphone-13-pro-compatible-case-2-pk-5" rel="sponsored" target="_blank">在 Woot 上 Amazon Prime 仅需 13.99 美元</a></li><li>Apple Watch Series 5，有划痕和凹痕<a href="https://www.jdoqocy.com/click-1989299-13142105?sid=dd---&amp;url=https%3A%2F%2Fsellout.woot.com%2Foffers%2Fapple-watch-series-5-your-choice-sdopen-box-10" rel="sponsored" target="_blank">，Woot 售价 137.73 美元</a></li><li>Hiboy S2 电动滑板车，8.5 英寸实心轮胎，长达 17 英里，时速 19 英里（原价 499.99 美元，页面优惠券折扣 190 美元） <a href="https://www.amazon.com/dp/B086JHCJTX?&amp;tag=aidailydeals-20" rel="sponsored" target="_blank">，亚马逊售价 309.99 美元</a></li><li>Insignia 43 英寸 Class N10 系列 LED 全高清电视（原价 199.99 美元，节省 70 美元） <a href="https://shop-links.co/1816087525880795185?u1=dd---" rel="sponsored" target="_blank">，Best Buy 现价 129.99 美元</a></li><li>PlayStation 5 游戏机（原价 499.99 美元，10% 折扣） <a href="https://www.amazon.com/gp/product/B0BCNKKZ91?tag=aidailydeals-20" rel="sponsored" target="_blank">亚马逊售价 449 美元</a></li><li>Sennheiser HD 800 S 动态开放式立体声耳机（原价 1,799.95 美元，17% 折扣） <a href="https://adorama.rfvk.net/c/81003/51926/1036?subId1=dd---&amp;u=https%3A%2F%2Fwww.adorama.com%2Fse506911.html" rel="sponsored" target="_blank">，Adorama 现价 1,499.95 美元</a></li><li>Microsoft Office Home &amp; Business 2021，一次性购买 1 台 Mac，数字下载（原价 249.99 美元） <a href="https://shop.appleinsider.com/sales/microsoft-office-home-business-for-mac-2021-lifetime-license-6?utm_source=appleinsider.com&amp;utm_medium=referral&amp;utm_campaign=microsoft-office-home-business-for-mac-2021-lifetime-license-6_071423&amp;utm_term=scsf-575207&amp;utm_content=a0x1p000004ivavqa0&amp;scsonar=1" rel="sponsored" target="blank">，StackCommerce 售价 39.99 美元</a>， <a href="https://www.jdoqocy.com/click-1989299-13142085?sid=dd---&amp;url=https%3A%2F%2Fcomputers.woot.com%2Foffers%2Fmicrosoft-office-home-business-2021-for-mac%3F" rel="sponsored" target="_blank">Woot 售价 49.99 美元</a></li><li>Neat Bumblebee II - 专业心形定向 USB 电容麦克风（原价 99.99 美元，75% 折扣） <a href="https://www.dpbolvw.net/click-1989299-13142092?sid=dd---&amp;url=https%3A%2F%2Felectronics.woot.com%2Foffers%2Fnew-neat-bumblebee-ii-professional-cardioid-usb-condenser-microphone" rel="sponsored" target="_blank">，Woot 售价 24.99 美元</a></li><li>LG XBOOM Go 无线蓝牙音箱（原价 99.99 美元，53% 折扣）现价<a href="https://www.kqzyfj.com/click-1989299-13142105?sid=dd---&amp;url=https%3A%2F%2Fsellout.woot.com%2Foffers%2Fnew-lg-xboom-go-pl5-wireless-bluetooth-speaker-open-box-4%3Fref%3Dw_cnt_lnd_cat_elec_1_24" rel="sponsored" target="_blank">47.49 美元，Woot</a> </li></ul></div><div class="col-sm-12"><h2 data-anchor="more-tech-deals--steals" id="more-tech-deals--steals">更多技术交易和窃取</h2></div><div class="col-sm-12"><div class="align-center"><a href="https://photos5.appleinsider.com/gallery/55762-113298-daily-deals-Aug-7-2-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55762-113298-daily-deals-Aug-7-2-xl.jpg" alt="购买 M2 Pro 14 英寸 MacBook Pro 立省 250 美元" height="731" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"><span class="carousel-caption">购买 M2 Pro 14 英寸 MacBook Pro 立省 250 美元</span></div></div><div class="col-sm-12"><p>您仍然可以购买我们周日发布的大部分优惠。查看昨天最热门的特价商品以获得最低价格。</p></div><div class="col-sm-12"><ul><li> 14 英寸 MacBook Pro M2 Pro（12 核 CPU、19 核 GPU）、16GB 内存、1TB SSD、深空灰：Apple 经销商<a href="https://prices.appleinsider.com/product/macbook-pro-14-inch-2023/mphf3ll/a">售价 2,249 美元（优惠 250 美元）</a></li><li> Prism Drive 安全云存储：终身订阅 (20TB)：StackCommerce <a href="https://shop.appleinsider.com/sales/prism-drive-secure-cloud-storage-20tb-lifetime-subscription?utm_source=appleinsider.com&amp;utm_medium=referral&amp;utm_campaign=prism-drive-secure-cloud-storage-20tb-lifetime-subscription_080223&amp;utm_term=scsf-576647&amp;utm_content=a0x1p000005ot7uqas&amp;scsonar=1" rel="sponsored" target="blank">99.99 美元（33% 折扣）</a></li><li>飞利浦 Hue 白色和彩色 Ambiance Econic Square 户外壁灯和吸顶灯：亚马逊<a href="https://www.amazon.com/dp/B07NDF3VPH?th=1&amp;tag=aidailydeals-20" rel="sponsored" target="blank">143 美元（16% 折扣）</a></li><li> Dyson V15 Detect Extra 无绳吸尘器：Best Buy <a href="https://shop-links.co/1816001583416897754?u1=dd-othr-bby-dyson-v11-080523" rel="sponsored" target="blank">649.99 美元（优惠 150 美元）</a></li><li> Nintendo Switch OLED（日本型号）：Woot <a href="https://www.anrdoezrs.net/click-1989299-13142092?sid=dd-othr-woot-nintendo-switch-080623&amp;url=https%3A%2F%2Felectronics.woot.com%2Foffers%2Fnew-nintendo-switch-oled-japanese-model" rel="sponsored" target="blank">售价 289.99 美元（优惠 70 美元）</a></li><li> Target 计算器<a href="https://shop-links.co/1816016157618122371?u1=dd-othr-target-calculators-080623" rel="sponsored" target="blank">最高可节省 30%</a></li><li>东芝 43 英寸 Class C350 系列 LED 4K 超高清智能 Fire 电视（原价 329.99 美元，33% 折扣） <a href="https://www.amazon.com/gp/product/B0BTTX3Z1P?tag=aidailydeals-20" rel="sponsored" target="_blank">，亚马逊现价 219.99 美元</a></li></ul></div><div class="col-sm-12"><h2 data-anchor="plus-save-with-even-more-bargains" id="plus-save-with-even-more-bargains">另外，还可享受更多优惠</h2></div><div class="col-sm-12"><div class="align-center"><a href="https://prices.appleinsider.com/"><img src="https://photos5.appleinsider.com/gallery/47002-91572-Apple-Price-Guide-hero-graphic-xl.jpg" alt="最优惠的苹果价格" height="720" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div></div><div class="col-sm-12"><p>从 2023 款 MacBook Pro 到 M2 Mac mini， <em>AppleInsider</em>读者可以抢购更多 Apple 硬件的独家折扣。请务必访问我们的<a href="https://prices.appleinsider.com/">Apple 价格指南，</a>了解 Apple 经销商的最新销售和特别优惠。</p></div><div class="col-sm-12"><ul><li> <strong><a href="https://appleinsider.com/articles/23/08/02/apples-13-inch-m2-macbook-air-is-on-sale-for-949-just-in-time-for-back-to-school">Apple 13 英寸 M2 MacBook Air 在最新返校促销中售价 949 美元</a></strong></li><li><strong><a href="https://appleinsider.com/articles/23/08/03/exclusive-macbook-pro-14-16-inch-deals-save-up-to-1300-prices-start-at-1549">MacBook Pro 14 和 16 英寸专享优惠：最高节省 1,300 美元，起价 1,549 美元</a></strong></li><li><strong><a href="https://appleinsider.com/articles/23/07/08/lowest-price-ever-macbook-pro-14-inch-with-32gb-ram-1tb-ssd-on-sale-for-1999-plus-60-off-applecare">Apple MacBook Pro 14 英寸（配备 32GB RAM、1TB SSD）售价 1,999 美元，还可享受 60 美元的 AppleCare 优惠</a></strong></li><li><strong><a href="https://appleinsider.com/articles/23/08/06/grab-apples-m1-max-16-macbook-pro-with-64gb-ram-1tb-ssd-for-2599-1100-off">购买配备 64GB RAM、1TB SSD 的 Apple M1 Max 16 英寸 MacBook Pro，现价 2,599 美元（立减 1,100 美元）</a></strong></li></ul></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 14:50:02 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/daily-deals-200-off-15-macbook-air-apple-watch-from-137-office-for-mac-40-more</guid><link/> https://appleinsider.com/articles/23/08/07/daily-deals-200-off-15-macbook-air-apple-watch-from-137-office-for-mac-40-more <author><![CDATA[Jess Pingrey]]></author></item><item><title><![CDATA[Apple Watch accessory makers have to switch to newer, costlier fast-charging module]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>根据苹果的MFi计划，Apple Watch充电配件的生产商需要从苹果自己购买官方充电模块。这就是所有 Apple Watch 充电器都采用相同标志性白色圆盘的原因。</p></div><div class="col-sm-12"><p>这一变化影响了第三方配件生产商，最终影响了消费者，在推出更新模块多年后，苹果公司将不再提供其旧充电模块的供应。</p></div><div class="col-sm-12"><p>苹果最初<a href="https://appleinsider.com/articles/22/02/02/apple-watch-series-7-has-a-fast-charging-problem">缺乏</a>较新的充电模块。不愿透露姓名的供应商向<em>AppleInsider</em>表示，由于供应限制和快速充电模块的交货时间较长，他们经常被迫发布配备较慢充电模块的产品。</p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><div class="col-sm-12"><p> 消费者在购买新发布的缺乏最新规格的充电配件时陷入了不利的境地。</p></div><div class="col-sm-12"><p>据来自配件供应商的<em>AppleInsider</em>消息人士透露，苹果公司已经发出警告，称其正在专注于生产具有快速充电功能的新型模块。苹果更新了该模块以配合<a href="https://appleinsider.com/inside/apple-watch-series-7" title="苹果手表系列 7" data-kpt="1">Apple Watch Series 7</a> ，为可穿戴设备阵容增加了快速充电功能。</p></div><div class="col-sm-12"><p>配件制造商必须在 2023 年 8 月 31 日之前向 Apple 提交包含原始 C162 慢充模块的产品计划以供批准。但 2023 年 9 月 30 日是订购该版本的最后日期，此后所有新配件将被迫使用更新的 C962 快速充电模块。</p></div><div class="col-sm-12"><p>对于消费者来说，这意味着随着苹果解决供应问题，市场上应该会有大量新的快速充电 Apple Watch 配件上市。不过，据信苹果向供应商收取了更高的快充模块费用，因此消费者可能会看到价格上涨。</p></div><div class="col-sm-12"><p>在<a href="https://appleinsider.com/inside/iphone" title="iPhone" data-kpt="1">iPhone</a>方面，消息人士还表示，苹果将提供 MFM 和 Qi2 无线充电模块。目前尚不清楚为什么制造商会选择 MFM 模块而不是 Qi2 模块，因为后者的价格明显更便宜。</p></div><div class="col-sm-12"><p>这一变化<a href="https://appleinsider.com/articles/23/05/24/apple-rumored-to-drop-limits-on-15w-wireless-chargers-for-iphone-15">进一步证实</a>了苹果将在新的<a href="https://appleinsider.com/inside/iphone" title="iPhone" data-kpt="1">iPhone</a>机型中加入 Qi2 支持。 Qi2 <a href="https://appleinsider.com/articles/23/01/10/future-of-magsafe-and-the-new-qi2-wireless-charging-spec">于 1 月</a>推出，是 Qi 的替代品，基于 Apple <a href="https://appleinsider.com/inside/magsafe" title="磁安全" data-kpt="1">MagSafe</a> 。</p></div><div class="col-sm-12"><p> Apple 直接向无线充电联盟贡献了其 MagSafe 技术，新标准将采用<a href="https://appleinsider.com/inside/magsafe" title="磁安全" data-kpt="1">MagSafe</a>式磁环和高达 15W 的无线充电。</p></div><div class="col-sm-12"><p>最近，苹果稍微开放了 MFM 规范， <a href="https://appleinsider.com/articles/22/10/25/third-party-magsafe-accessories-are-about-to-look-a-lot-nicer">允许充电配件</a>利用纯白圆圈之外的不同充电表面。</p></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 14:36:41 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/apple-watch-accessory-makers-have-to-switch-to-newer-costlier-fast-charging-module</guid><link/> https://appleinsider.com/articles/23/08/07/apple-watch-accessory-makers-have-to-switch-to-newer-costlier-fast-charging-module <author><![CDATA[Malcolm Owen]]></author></item><item><title><![CDATA[Sonos Move 2 leaks, Hue creates cameras, & Snoo smart bassinet review on the HomeKit Insider Podcast]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>本周，未发布的 Sonos Move 2 提前泄露。这次泄露证实了许多预期的细节，例如改进的控制装置、双立体声驱动器、增强的电池寿命等等。</p></div><div class="col-sm-12"><p>它似乎还采用了新的橄榄绿配色以及白色和黑色。预计今年九月推出。</p></div><div class="col-sm-12"><p>在 Signify 首席执行官埃里克·朗多拉特 (Eric Rondolat) 在财报电话会议上透露即将推出的产品后，飞利浦 Hue 打算进军相机市场，推出多种选择，包括泛光灯相机、有线相机和电池供电相机。不过没有关于 HomeKit 支持的消息。</p></div><div class="col-sm-12"><p>本周的其他新闻包括新 Matter 交换机的推出、Eero 6 Pro 路由器的更新以及 Roborock 加入 CSA。 </p></div><div class="col-sm-12 embed"><div class="align-center"><div class="embed-responsive embed-responsive-16by9 video-holder"><iframe src="https://www.youtube.com/embed/-gfkAAx_v9g" title="YouTube 视频播放器" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" class="embed-responsive-item" loading="lazy" referrerpolicy="no-referrer"></iframe><em><a href="https://www.youtube.com/c/appleinsider?sub_confirmation=1">在 YouTube 上订阅 AppleInsider</a></em></div><em><a href="https://www.youtube.com/c/appleinsider?sub_confirmation=1">在 YouTube 上订阅 AppleInsider</a></em></div></div><div class="col-sm-12"><p>我们的嘉宾主持人费思·奥哈拉 (Faith O&#39;Hara) 也为我们评测了 Snoo 智能摇篮，它可以摆动，帮助您的小宝贝入睡。</p></div><div class="col-sm-12"><h2 data-anchor="links-from-the-show" id="links-from-the-show">节目链接</h2></div><div class="col-sm-12"><ul><li><a href="https://www.theverge.com/2023/8/2/23817225/sonos-move-2-speaker-features-specs-price">Sonos Move 2 泄露</a></li><li><a href="https://hueblog.de/2023/08/02/hue-neuheiten-vier-kameras-kontaktsensoren-und-12-volt-spots/">Hue 相机阵容揭晓</a></li><li><a href="https://twitter.com/csaiot/status/1687484272305897472?s=20%20">Roborock 加入 CSA</a></li><li> <a href="https://www.happiestbaby.com/products/snoo-smart-bassinet">Snoo 智能摇篮</a></li><li><a href="https://appleinsider.com/articles/23/08/07/Faith%20O'Hara's%20Instagram">https://www.instagram.com/faithohara89/?hl=en</a></li></ul></div><div class="col-sm-12"><p>订阅并收听我们的<a href="https://podcasts.apple.com/us/podcast/appleinsider-daily/id1532419028">AppleInsider Daily 播客</a>，了解周一至周五的最新 Apple 新闻。您可以在<a href="https://podcasts.apple.com/us/podcast/appleinsider-daily/id1532419028">Apple Podcasts</a> 、 <a href="https://overcast.fm/itunes1532419028/appleinsider-daily">Overcast</a>或任何您收听播客的地方找到它。</p></div><div class="col-sm-12"><p>有兴趣赞助该节目的人可以通过以下方式联系我们： <a href="https://appleinsider.com/cdn-cgi/l/email-protection#13727d77617664537263637f767a7d607a7776613d707c7e"><span class="__cf_email__" data-cfemail="f899969c8a9d8fb8998888949d91968b919c9d8ad69b9795">[email protected]</span></a> </p></div><div class="col-sm-12 embed"><div class="align-center"><div class="embed"><iframe id="embedPlayer" src="https://embed.podcasts.apple.com/us/podcast/sonos-move-2-revealed-philips-hue-cameras-snoo-smart/id1515834398?i=1000623633610&amp;itsct=podcast_box_player&amp;itscg=30200&amp;ls=1&amp;theme=auto" frameborder="0" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation" allow="autoplay *; encrypted-media *; clipboard-write" style="width: 100%; max-width: 660px; overflow: hidden; border-radius: 10px; transform: translateZ(0px); animation: 2s ease 0s 6 normal none running loading-indicator; background-color: rgb(228, 228, 228);" class="embed-responsive-item" loading="lazy" width="100%" referrerpolicy="no-referrer"></iframe></div></div></div><div class="col-sm-12"><p><em>在每周 AppleInsider 播客中了解 Apple 的最新动态，并从 AppleInsider Daily 获取快速新闻更新。只需对您的<a href="https://appleinsider.com/inside/homepod-mini" title="HomePod 迷你" data-kpt="1">HomePod mini</a>说“嘿，Siri”并请求这些播客以及我们最新的 HomeKit Insider 剧集。如果您想要无广告的主要 AppleInsider Podcast 体验，您可以<a href="https://podcasts.apple.com/us/podcast/appleinsider-podcast/id963144241?i=1000525946824">通过 Apple 的 Podcasts 应用程序</a>订阅 AppleInsider 播客，每月支付 5 美元，如果您喜欢任何其他播客播放器，也可以<a href="https://patreon.com/appleinsider">通过 Patreon</a>订阅。</em></p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 14:18:09 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/sonos-move-2-leaks-hue-creates-cameras-snoo-smart-bassinet-review-on-the-homekit-insider-podcast</guid><link/> https://appleinsider.com/articles/23/08/07/sonos-move-2-leaks-hue-creates-cameras-snoo-smart-bassinet-review-on-the-homekit-insider-podcast <author><![CDATA[Andrew O&#39;Hara]]></author></item><item><title><![CDATA[Profits are still down but Foxconn expects bump from iPhone 15]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>富士康公布的 2023 年 1 月至 3 月第一季度数据显示，利润较去年同期下降 56%。这是该公司三年来<a href="https://appleinsider.com/articles/23/05/11/foxconn-has-a-grim-outlook-for-the-year-as-profits-take-a-nosedive">最大的季度跌幅</a>。</p></div><div class="col-sm-12"><p>现在据<em>路透社报道</em>，富士康公布了2023年7月的数据，仍低于上年同期，但仅下降了1.23%。收入较 2023 年 6 月增长近 11%，达到 148.2 亿美元。</p></div><div class="col-sm-12"><p>此前，7 月公布的 2023 年 4 月至 5 月至 6 月季度业绩同比下降 13.3%。</p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><div class="col-sm-12"><p> 尽管如此，该公司表示预计会出现反弹。</p></div><div class="col-sm-12"><p>富士康母公司鸿海精密工业股份有限公司在一份声明中表示，“随着下半年旺季的到来，运营将逐渐加快。” “第三季度的前景将好于第二季度，预计季度增长速度将高于前两年。”</p></div><div class="col-sm-12"><p>富士康还表示，这一最新数字是 7 月份的第二高数字。它将增长归因于苹果和其他供应商准备推出<a href="https://appleinsider.com/inside/iphone-15" title="iPhone 15" data-kpt="1">iPhone 15</a>系列等产品。</p></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 13:40:24 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/profits-are-still-down-but-foxconn-expects-bump-from-iphone-15</guid><link/> https://appleinsider.com/articles/23/08/07/profits-are-still-down-but-foxconn-expects-bump-from-iphone-15 <author><![CDATA[William Gallagher]]></author></item><item><title><![CDATA[Hyper fields HyperDrive Next collection of a dock, SSD enclosure, and hubs]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>该公司表示，周一推出的 HyperDrive Next 系列通过将创造力与创新和环境责任相结合，“证明了我们致力于突破界限”。</p></div><div class="col-sm-12"><p>该系列包括四种产品，即精选的 USB-C 集线器、USB4 NVMe SSD 外壳、针对 M1 和 m2 Mac 的支持双显示器的 USB-C 扩展坞，以及 USB-C 商务级扩展坞。</p></div><div class="col-sm-12"><p> USB-C 集线器提供 4 到 11 个端口，承诺通过 10Gb USB 传输将速度提高一倍，通过 SD 4.0 312Mbs 端口将数据传输速率提高三倍，通过 140W PD 3.1 端口将直通功率提高 40%。这些集线器还支持 4K60Hz HDMI 连接，由 100% 再生铝和 85% 再生塑料制成。</p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><div class="col-sm-12"><p> HyperDrive Next USB4 NVMe SSD 机箱可在直接从 SSD 工作的同时实现高达 40Gbps 的数据传输。该外壳同样由 100% 再生铝制成，具有 IP55 防水防尘等级，可与容量高达 16TB 的 M.2 NVMe SSD 兼容。</p></div><div class="col-sm-12"><p> Hyper 正在<a href="https://click.linksynergy.com/deeplink?id=SnlbqrT3b2s&amp;mid=43456&amp;u1=pa---&amp;murl=https%3A%2F%2Fwww.hypershop.com%2Fproducts%2Fhyperdrive-next-usb4-nvme-ssd-enclosure" rel="sponsored">以 119.99 美元的价格</a>出售 HyperDrive Next USB4 NVMe SSD 外壳。</p></div><div class="col-sm-12"><div class="align-center"> <a href="https://photos5.appleinsider.com/gallery/55766-113300-hyper-enclosure-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55766-113300-hyper-enclosure-xl.jpg" alt="HyperDrive Next USB4 NVMe SSD 机箱" height="731" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div></div><div class="col-sm-12"><p>继<a href="https://appleinsider.com/articles/22/03/07/hypers-hyperdrive-10-in-1-usb-c-hub-review-use-two-4k-displays-with-your-m1-mac">HyperDrive 10 合 1 USB-C 集线器</a>之后，HyperDrive Next 10 端口商务级 USB-C 扩展坞支持双 4K 显示器，其中包括 10Gbps USB 端口、支持存储卡数据传输的 SD 4.0，以及可拆卸的 USB-C 电缆。它还采用纤薄设计，便于携带，并且由 85% 的再生塑料制成。</p></div><div class="col-sm-12"><p>最后，HyperDrive Next Duak 4K HDMI 7 端口 USB-C 集线器为 M1 和 M2 MacBook 提供双 4K 显示器支持，超越了 Apple 的限制。同样，它还有用于快速数据传输的 10Gbps USB 端口、100W PD 电源直通端口，并且由 85% 的再生塑料制成。</p></div><div class="col-sm-12"><p>除了可从 Hyper 的在线<a href="https://click.linksynergy.com/deeplink?id=SnlbqrT3b2s&amp;mid=43456&amp;u1=pa---&amp;murl=https%3A%2F%2Fwww.hypershop.com%2Fpages%2Fgo-beyond" rel="sponsored">店面</a>购买外，其许多集线器和扩展坞也将于 8 月中旬在百思买 (Best Buy) 上销售。</p></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 12:51:01 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/hyper-fields-hyperdrive-next-collection-of-a-dock-ssd-enclosure-and-hubs</guid><link/> https://appleinsider.com/articles/23/08/07/hyper-fields-hyperdrive-next-collection-of-a-dock-ssd-enclosure-and-hubs <author><![CDATA[Malcolm Owen]]></author></item><item><title><![CDATA[Apple could raise iPhone 15 Pro storage to 2TB]]></title><description><![CDATA[<p class="col-sm-12 article-lead"> <a href="https://appleinsider.com/inside/iphone-15" title="iPhone 15" data-kpt="1">iPhone 15</a> Pro 可以为潜在买家提供更多的使用空间，有传言称苹果可能会将最大存储容量提高到 2TB。</p><div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>苹果目前销售的<a href="https://appleinsider.com/inside/iphone-14-pro" title="iPhone 14 专业版" data-kpt="1">iPhone 14 Pro</a>和 iPhone 14 Pro Max 有四种容量可供选择，从 128GB 到 1TB。对于秋季产品阵容，苹果可能会更进一步。</p></div><div class="col-sm-12"><p>在 Naver 上的一篇帖子中，连续爆料者“Yeux1122”<a href="https://m.blog.naver.com/yeux1122/223175715389">声称</a>iPhone 15 Pro 和 iPhone 15 Pro Max 机型将在 2023 年提供 2 TB 选项。除了来自供应商的消息外，爆料者没有提供任何其他细节。</p></div><div class="col-sm-12"><p>虽然有关扩展存储空间的传言尚未流传，但有人提议苹果可能会<a href="https://appleinsider.com/articles/23/07/27/iphone-15-pro-again-rumored-to-cost-more-than-ever-before">提高 Pro 型号的成本</a>。除了<a href="https://appleinsider.com/articles/23/07/10/iphone-15-and-iphone-15-pro-what-the-rumors-say-is-landing-this-fall">预期的价格上涨</a>之外，存储容量的增加可能有助于鼓励消费者为他们的设备支付更多费用。</p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><div class="col-sm-12"><p> 对于一些用户，尤其是摄像师和创意人员来说，在拍摄大量 4K 素材时，额外的容量会受到欢迎。虽然 1TB 对于大多数用户来说已经很大了，但视频是一种消耗量很大的文件类型，一些用户可能会认为额外的 TB 是合理的。</p></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 11:57:58 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/apple-could-raise-iphone-15-pro-storage-to-2tb</guid><link/> https://appleinsider.com/articles/23/08/07/apple-could-raise-iphone-15-pro-storage-to-2tb <author><![CDATA[Malcolm Owen]]></author></item><item><title><![CDATA['Ted Lasso' VFX compositing supervisor talks crowd effects at event]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>周日， <a href="https://appleinsider.com/inside/apple-tv-plus" title="苹果电视+" data-kpt="1">Apple TV+</a>和<em>Deadline</em>举办了首届<a href="https://appleinsider.com/articles/23/08/05/vfx-behind-apple-tv-shows-revealed-in-special-event-on-sunday">Visual Effects + Screen</a>活动，展示了 Apple TV+ 某些节目的数字特效方面的一些工作。</p></div><div class="col-sm-12"><p><em>据 Deadline</em> <a href="https://deadline.com/2023/08/bill-parker-ted-lasso-vfx-compositing-supervisor-visual-effects-screen-1235456041/">报道</a>，在谈到“Ted Lasso”时，视觉特效合成主管 Bill Parker 解释说，该剧的一大亮点是让足球场充满了支持者。然而，虽然在视觉特效项目中制造人群很常见，但帕克表示，“需要完成的镜头数量和数量”使“特德·拉索”与众不同。</p></div><div class="col-sm-12"><p> “当你观看我们制作的任何一集时，你会看到两种不同的东西，”帕克解释道。 “要么根本没有体育场，里面都是空的，要么他们有时会在真正的体育场上进行防空洞投篮，而我们只是在座位上增加人。”</p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><div class="col-sm-12"><p> 团队必须想出一种“非常强大的方法，能够根据我们所拍摄的镜头来改变技术”，部分原因是第三个赛季使用了超过一千个镜头。使用多种“人群技术”，例如创建瓷砖板和精灵，甚至制作计算机生成的人群，体育场可靠地充满了数字临时演员。</p></div><div class="col-sm-12"><p>帕克还观察到，与其他人相比，足球观众可能相当反动。 “每个人都非常投入，所以这也成为工作的重要组成部分，”他解释道，并且他“真正地调动了这些情绪”以匹配场上的行动。</p></div><div class="col-sm-12"><p>帕克在《泰德·拉索》中的作品获得了<a href="https://appleinsider.com/articles/23/07/12/apple-tv-gains-51-emmy-awards-led-once-more-by-ted-lasso">艾美奖提名</a>，其中《妈妈城市》一集让他在单集杰出视觉效果类别中占有一席之地。</p></div><div class="col-sm-12"><p>出席的还有《纪念阵亡五日》的埃里克·杜斯特、《基地》的克里斯·麦克莱恩和《筒仓》的丹尼尔·劳赫韦格。</p></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 10:53:54 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/23/08/07/ted-lasso-vfx-compositing-supervisor-talks-crowd-effects-at-event</guid><link/> https://appleinsider.com/articles/23/08/07/ted-lasso-vfx-compositing-supervisor-talks-crowd-effects-at-event <author><![CDATA[Malcolm Owen]]></author></item><item><title><![CDATA[The cheesegrater Mac Pro could still be the best Mac ever made]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><p>最新的 Mac Pro 是最后一款从 Intel 处理器过渡到 Apple Silicon 的 Mac。但正是在苹果公司进行之前的巨大转型（从 PowerPC 转向英特尔）时，初代 Mac Pro 才首次问世。</p></div><div class="col-sm-12"><p>但就像现在一样，Mac Pro 向新处理器的过渡花费的时间比用户希望的要长。 </p></div><div class="col-sm-12"><h2 data-anchor="intel-promised-unimaginable-speed" id="intel-promised-unimaginable-speed">英特尔承诺超乎想象的速度</h2></div><div class="col-sm-12"><p>Mac Pro 发布前两年，即 2005 年 6 月 6 日，<a href="https://appleinsider.com/inside/steve-jobs">史蒂夫·乔布斯</a>正式透露，长期以来的传言是真的，苹果将在 Mac 上改用英特尔处理器。那一年，他详细介绍了公司的路线图。 </p></div><div class="col-sm-12 embed"><div class="align-center"><div class="embed-responsive embed-responsive-16by9 video-holder"><iframe src="https://www.youtube.com/embed/ghdTqnYnFyg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="" class="embed-responsive-item" loading="lazy" referrerpolicy="no-referrer"></iframe></div></div></div><div class="col-sm-12"><p>他在 2005 年 WWDC 上表示：“从明年开始，我们将开始推出配备英特尔处理器的 Mac。因此，当我们明年这个时候再次见面时，我们的计划是届时推出配备英特尔处理器的 Mac。”</p></div><div class="col-sm-12"><p> “当我们两年后再次在这里聚会时，我们的计划是过渡将基本完成，”他继续说道。 “我们认为它将在 2007 年底完成。所以这是一个为期两年的过渡。”</p></div><div class="col-sm-12"><p>这是苹果公司迄今为止最清楚的说法，如果乔布斯对这一转变的解释听起来很熟悉的话，那就应该如此。<a href="https://appleinsider.com/inside/tim-cook">蒂姆·库克 (Tim Cook)</a>在宣布迁移到 Apple Silicon 时遵循了<a href="https://appleinsider.com/articles/20/06/29/tim-cook-apple-silicon-transition-follows-steve-jobs-intel-shift-script">完全相同的策略</a>。</p></div><div class="col-sm-12"><p>当时和现在一样的大新闻是，该系列中的每台 Mac 都将配备英特尔处理器，这显然是件好事，但乔布斯特别承诺更快、更强大的机器。最需要电力的地方就是后来的 Mac Pro。</p></div><div class="col-sm-12"><p>在英特尔转型之初，我们并不知道这个名字，但我们确实知道它的形式，因为已经有一款名为 Power Mac G5 的顶级 PowerPC 型号采用相同的机箱。</p></div><div class="col-sm-12"><p>乔布斯给出的从 PowerPC 转向英特尔的原因之一显然与该机器及其开发有关。站在一张显示 PowerMac G5 的幻灯片前，上面写着“3.0GHz？”乔布斯有很多话要说。</p></div><div class="col-sm-12"><p> “两年前我站在这里，我向你保证了这一点，”乔布斯指着屏幕说道。 “我们还无法将其交付给您。”</p></div><div class="col-sm-12"><p> “展望未来，我们可以设想一些我们想要为您构建的令人惊叹的产品，”他继续说道，“但我们不知道如何根据未来的 PowerPC 路线图来构建它们。”</p></div><div class="col-sm-12"><p> Power Mac G5 很受欢迎，因为它是当时功能最强大的 Mac，但要创造成功，需要比性能更难以定义的东西，而这款机器从来没有像 Mac Pro 那样受到纯粹的喜爱。</p></div><div class="col-sm-12"><p>因此，尽管有很多希望和期待，但直到 2006 年 8 月 7 日星期一东部时间下午 1:08，Mac Pro 才发布，并开始走上成为受人喜爱的经典之路。</p></div><div class="col-sm-12"><p> “[2006 年] 的前两个季度，我们几乎将所有产品都转向了英特尔。除了 Power Mac 之外，”乔布斯当时宣称。 “好吧，今天 Power Mac 将消失在历史之中。” </p></div><div class="col-sm-12 embed"><div class="align-center"><div class="embed-responsive embed-responsive-16by9 video-holder"><iframe src="https://www.youtube.com/embed/l72MsGZQA8Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="" class="embed-responsive-item" loading="lazy" referrerpolicy="no-referrer"></iframe></div></div></div><div class="col-sm-12"><p><a href="https://appleinsider.com/inside/phil-schiller">菲尔·席勒</a>随后上台展示了与之前<a href="https://appleinsider.com/articles/06/07/14/apples_mac_pro_to_sport_modified_power_mac_enclosure">完全相同</a>的机器。</p></div><div class="col-sm-12"><p>也许这在今天看来并不令人惊讶，因为苹果硅 Mac 花了一代人的时间才摆脱了前辈的底盘。但回到 2006 年，看到同样的大型铝制外壳、同样的提手手柄以及同样方便进入内部的情况，真是令人惊讶。</p></div><div class="col-sm-12"><p>席勒很快就为它辩护，这足以令人惊讶。</p></div><div class="col-sm-12"><p> “我们拥有业内最好的外壳，这是一个漂亮的外壳设计，”他说。 “从外观上看，它拥有以前的所有优点。从内部看，它是全新的。”</p></div><div class="col-sm-12"><h2 data-anchor="performance-promise" id="performance-promise">性能承诺</h2></div><div class="col-sm-12"><p>这第一台 Mac Pro 确实达到了乔布斯承诺的 3.0GHz 性能，而且它采用了英特尔的 Xeon 处理器。</p></div><div class="col-sm-12"><p> “这是我们许多高端客户所梦想的 Mac，”席勒说道。 “对于我们的最高端客户来说，这是他们真正想要的功能：它们是 64 位的。”</p></div><div class="col-sm-12"><p> “因此，这款新的英特尔至强芯片是一款令人惊叹的处理器，可以放入我们的产品中，但在每台 Mac Pro 中，我们将放入两个处理器，”他继续说道。 “所有 Mac Pro 均具有四核 Xeon 性能。这些都是速度惊人的机器。”</p></div><div class="col-sm-12"><p>似乎每台新 Mac 都是 Apple 有史以来最快的 Mac，但<a href="https://appleinsider.com/articles/06/08/07/apple_unveils_quad_core_64_bit_mac_pro_desktops">这款 Mac</a>却实现了巨大飞跃，据称其性能比 Power Mac G5 提高了一倍。也许直到 Apple Silicon 的推出，速度才出现了如此显着的提升。</p></div><div class="col-sm-12"><p>这款 Mac Pro 还提高了每瓦功率的性能。通常，当您构建笔记本电脑并平衡工作和电池寿命的需求时，这是一个问题，但席勒指出，这对于这款台式机也有很大的好处。</p></div><div class="col-sm-12"><p> “每瓦性能意味着我们在机箱内需要更少的冷却系统。这意味着我们可以利用我们拥有的空间做更多事情，”他说。 “因此，我们将 Mac Pro 内的驱动器数量增加了一倍，现在有四个硬盘，内部存储容量高达 2TB。”</p></div><div class="col-sm-12"><p>现在还有第二个光驱，以及连接更多外部设备的空间，位于机器的背面 - 现在也位于前面。</p></div><div class="col-sm-12"><p>正面增加了第二个 USB 2.0 端口和 Firewire 800，而背面最显着的变化是双宽显卡插槽，允许安装最大、最强大的 GPU，而无需牺牲相邻插槽。</p></div><div class="col-sm-12"><p>因此，新款 Mac Pro 的速度“快得让人尖叫”，它具有更大的扩展性，但扩展的方式仍然是同样令人羡慕的简单方式。该外壳让您只需打开整个侧面，然后就可以插入新的硬盘驱动器，而无需任何布线或摆弄。</p></div><div class="col-sm-12"><p>这款 Mac Pro 可以深度定制，速度极快，配备 1GB RAM，但可以处理 32GB RAM，Schiller 宣布它现已上市。</p></div><div class="col-sm-12"><p> 2006 年 8 月 7 日，您可以花 2,499 美元购买一台。以 2023 年的价格计算，这大约是 3,677 美元，大约是当今 Mac Pro 成本的一半。</p></div><div class="col-sm-12"><h2 data-anchor="not-standing-still" id="not-standing-still">没有站着不动</h2></div><div class="col-sm-12"><p>这款最初的 Mac Pro（版本 1,1）一直在销售，直到 2007 年 4 月才出现减速。然后版本 2,1 一直持续到第二年 1 月，当时 3,1 版本通过更快的四核 Intel Xeon 5400 处理器提升了性能。您还可以将其升级为拥有两个这样的处理器以及高达 32GB 的 RAM。</p></div><div class="col-sm-12"><p>另一个重大更新是在 2010 年 7 月，除了迁移到 Intel 的 Xeon 5600 系列处理器外，您现在还可以拥有高达 64GB RAM 和 8TB 存储空间。</p></div><div class="col-sm-12"><p>这个版本一直是苹果的旗舰机型，直到这面旗帜摇摇欲坠。两年后，Mac Pro 再次更新，2012 年 7 月发布的 Mac Pro 现在配备了两个 6 核 2.4 GHz Intel Xeon Westmere-EP 处理器。</p></div><div class="col-sm-12"><p>从外面看，它还是一模一样，这很好，但里面现在看起来也很旧了。它正在更新，但内部不再有根本性的改进，因此苹果的专业用户开始叫嚣。</p></div><div class="col-sm-12"><p>苹果似乎正在对其专业用户失去兴趣。看起来苹果甚至可能已经失去了生产创新 Mac 的著名能力。 </p></div><div class="col-sm-12"><h2 data-anchor="the-difficult-second-album" id="the-difficult-second-album">困难的第二张专辑</h2></div><div class="col-sm-12"><p>即使在设备快速发展的技术领域，也很难取得成功。奶酪刨丝机 Mac Pro 已经问世几年了，苹果可以而且需要对其进行彻底改造，以利用更新的技术。</p></div><div class="col-sm-12"><p>这正是苹果所做的，最初，这款经过改进的新款 Mac Pro 似乎非常出色。但它并没有保持这种状态，但在 WWDC 2013 上，当苹果公司<a href="https://appleinsider.com/articles/13/06/10/apple-offers-sneak-peek-at-new-cylindrical-mac-pro-assembled-in-the-usa">先睹为快</a>时，我们都为菲尔·席勒 (Phil Schiller) 的台词鼓掌，“不能创新，我的屁股。”</p></div><div class="col-sm-12"><p>然而，与奶酪刨丝机 Mac Pro 不同的是，他无法透露这曾经是苹果发布的主要内容。他不能随便说新款 Mac Pro 今天发货了。</p></div><div class="col-sm-12"><p>甚至还差得很远。</p></div><div class="col-sm-12"><p>相反，席勒透露该产品将在当年晚些时候发货，而且确实在 2013 年 12 月 19 日发货，但只是勉强发货。 </p></div><div class="col-sm-12 embed"><div class="align-center"><div class="embed-responsive embed-responsive-16by9 video-holder"><iframe src="https://www.youtube.com/embed/ujvZJxn4mvo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="" class="embed-responsive-item" loading="lazy" referrerpolicy="no-referrer"></iframe></div></div></div><div class="col-sm-12"><p>这款 2013 款 Mac Pro 是近十年来第一款没有采用自 2004 年 6 月 Power Mac G5 以来一直使用的“漂亮外壳”的产品。</p></div><div class="col-sm-12"><p>这是一个新的外壳，看起来确实很漂亮，而且令人惊讶的是，它的外形比它的前身更小。 2013 款 Mac Pro 的高度为 9.9 英寸，而奶酪刨丝器型号的高度为 20.1 英寸，是其两倍多一点。</p></div><div class="col-sm-12"><p>奶酪刨丝器型号也为 8.1 英寸宽、18.7 英寸深，而新型号为圆形，直径为 6.6 英寸。因此，无论百分比差异如何，相比之下，2013 年 Mac Pro 看起来就像一个小垃圾桶。</p></div><div class="col-sm-12"><p>它很小，但令人印象深刻——但不幸的是它有缺陷。</p></div><div class="col-sm-12"><p>虽然专业用户立即批评其缺乏可扩展性和模块化，但随着时间的推移，人们发现它存在一个根本性的弱点。</p></div><div class="col-sm-12"><p>这种令人印象深刻的新设计由于其“热角”而在负载下崩溃。由于通风不足，它的运行速度受到了限制。</p></div><div class="col-sm-12"><p>这一点很明显，但在发布时，<a href="https://appleinsider.com/articles/14/01/09/review-apples-redesigned-late-2013-mac-pro">第一批评论</a>都非常积极，尽管他们抱怨 2013 Mac Pro 缺乏升级选项。</p></div><div class="col-sm-12"><p>然而，由于存在这些性能瓶颈，2013 年 Mac Pro 并不是人们想要的 2006 年 Mac Pro 的真正继承者。尽管它看起来确实很棒。</p></div><div class="col-sm-12"><p> 2013 年 Mac Pro 发布时的售价为 2,999 美元（现在为 3927 美元），事后看来，它是失败的 - 但只是事后看来。即使它没有像 2006 年的 Mac Pro 那样成为绝对的最爱，它仍然有它的粉丝——这不是通风双关语——视频编辑套件开始依赖它。 </p></div><div class="col-sm-12"><h2 data-anchor="apple-took-its-eye-off-the-ball" id="apple-took-its-eye-off-the-ball">苹果把目光从球上移开</h2></div><div class="col-sm-12"><p>我们永远不会真正知道苹果在英特尔时代的剩余时间里如何看待 Mac Pro，但它永远不会像 iPhone 那样成为疯狂的畅销品。发布后不久，甚至有迹象表明苹果已经忘记了 2013 年 Mac Pro。</p></div><div class="col-sm-12"><p>例如，2014 年就没有任何更新。</p></div><div class="col-sm-12"><p> 2015 年也没有。</p></div><div class="col-sm-12"><p>事实上，直到 2017 年，苹果才对圆柱形 Mac Pro 采取任何行动，然后宣布其死亡。</p></div><div class="col-sm-12"><p>苹果将​​继续销售同样的、一模一样的 Mac Pro 直到 2019 年，但销售变得越来越困难，因为它一直存在同样的问题，而且它的老化情况也不好。此外，苹果公司还采取了当时几乎闻所未闻的举措，承诺即将推出一款经过彻底改进的 Mac Pro。</p></div><div class="col-sm-12"><p>苹果也在 2017 年推出了<a href="https://appleinsider.com/inside/imac-pro">iMac Pro</a> 。对于许多用户来说，iMac Pro 与 2013 年的 Mac Pro 成功地进行了正面交锋，就像 2023 年的 Mac Studio 和 Mac Pro 势均力敌一样。</p></div><div class="col-sm-12"><p>苹果并没有表示从 2017 年的新闻发布到 2019 年的发布需要等待很长时间，但很明显，苹果确实明确指出，新款 Mac Pro 不会在 2017 年推出。</p></div><div class="col-sm-12"><p>只是，人们对这款新机的渴望如此强烈，以至于无数文章选择将其解读为它肯定会在 2018 年上市。这确实是一厢情愿地无视苹果公司异常简单的声明。</p></div><div class="col-sm-12"><p>虽然承诺的甚至只是传闻中的新苹果设备总是会受到关注，但 Mac Pro 的观众一直是热情的。毫无疑问，它的受众比任何其他 Mac 都要小得多，但成本可能也是受众的一个因素，但它远不是唯一的因素。</p></div><div class="col-sm-12"><p>相反，这些受众愿意付出高昂的购买价格来购买真正强大的 Mac Pro，因为它的工作流程明显加快，计算量大的任务的周转速度也明显加快。</p></div><div class="col-sm-12"><p>不管苹果是否真的忘记了这群观众，它肯定从 2013 年的 Mac Pro 中学到了这一点：这群观众不是注重成本而是渴望利益的。</p></div><div class="col-sm-12"><p>不过，用户的支出是有限的，当苹果推出 2019 年 Mac Pro 时，苹果就在大力推动这一举措。</p></div><div class="col-sm-12"><h2 data-anchor="mac-pro-2019" id="mac-pro-2019"> Mac Pro 2019</h2></div><div class="col-sm-12"><p> 2019 年 12 月 10 日发布时，2019 款 Mac Pro 起价为 5,999 美元，随后价格一路上涨。最大版本的<a href="https://appleinsider.com/articles/19/12/10/a-maxed-out-mac-pro-will-cost-you-53000----without-display">售价为 53,000 美元</a>——而且还是没有显示屏的版本。</p></div><div class="col-sm-12"><p>目标受众<a href="https://appleinsider.com/articles/19/06/14/high-end-users-on-why-im-buying-the-new-mac-pro">并不是非常关心</a>价格——同样，他们对此并不欣喜若狂，但在他们的用例中，这是一项值得的投资。但几乎每个人都嘲笑苹果如何<a href="https://appleinsider.com/articles/20/04/15/apples-mac-pro-wheels-cost-699-and-the-feet-run-299">以 699 美元的价格</a>向你出售一套 Mac Pro 轮子。</p></div><div class="col-sm-12"><p>尽管如此，当时看来这实际上是完美的 Mac Pro。也许它甚至可以继承 2006 年初代 Mac Pro 等深受喜爱的产品的衣钵，但它没有。</p></div><div class="col-sm-12"><p>不可能。 </p></div><div class="col-sm-12 embed"><div class="align-center"><div class="embed-responsive embed-responsive-16by9 video-holder"><iframe src="https://www.youtube.com/embed/GEZhD3J89ZE?start=5162" title="YouTube 视频播放器" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="embed-responsive-item" loading="lazy" referrerpolicy="no-referrer"></iframe></div></div></div><div class="col-sm-12"><div class="align-center"><em><a href="https://www.youtube.com/c/appleinsider?sub_confirmation=1">在 YouTube 上订阅 AppleInsider</a></em></div></div><div class="col-sm-12"><p>六个月零 12 天后的<a href="https://appleinsider.com/articles/20/06/22/apple-ceo-tim-cook-announces-shift-to-apple-silicon">2020 年 6 月</a>，苹果宣布过渡到 Apple Silicon。尽管没有透露任何细节，但再次承诺将大大提高性能。</p></div><div class="col-sm-12"><p>然后我们开始获取细节，这些细节几乎就是苹果所声称的。这与 2017 年 iMac Pro 经常击败当时的 Mac Pro 时不太一样，但第一代 Apple Silicon 只是一个小<a href="https://appleinsider.com/inside/mac-mini">Mac mini</a> ，这是一个惊人的飞跃。</p></div><div class="col-sm-12"><p> Apple Silicon was clearly working, it was radically improving performance, and it was doing it at a far lower cost than a 2019 Intel Mac Pro.</p></div><div class="col-sm-12"><p> It was enough that you would have had to have a very, very good use case — or someone else paying the money — to make buying the 2019 Mac Pro the right choice.</p></div><div class="col-sm-12"><p> You can&#39;t postpone your work while waiting for Apple, so there were still people for whom it was a sensible if expensive buy. But sales must surely have dropped, especially when it was certain the Mac Pro would be the pinnacle of Apple Silicon, and when it was probable it was coming soon.</p></div><div class="col-sm-12"><div class="align-center"> <a href="https://photos5.appleinsider.com/gallery/54780-110869-Mac-Pro-table-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/54780-110869-Mac-Pro-table-xl.jpg" alt="Apple Silicon Mac Pro 在 WWDC 上" height="738" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a> </div></div><div class="col-sm-12"><h2 data-anchor="completing-the-transition-to-apple-silicon" id="completing-the-transition-to-apple-silicon"> Completing the transition to Apple Silicon</h2></div><div class="col-sm-12"><p> It seems churlish to point this out when Apple has successfully pulled off an astounding complex transition from Intel to Apple Silicon, but it didn&#39;t make its own deadline. Tim Cook said it would take two years, and every Mac did make that transition — except the Mac Pro.</p></div><div class="col-sm-12"><p> Instead, it took three years for the <a href="https://appleinsider.com/articles/23/06/05/apple-silicon-mac-pro-debut-finally-ends-transition-away-from-intel-processors">announcement</a> of a new Mac Pro.</p></div><div class="col-sm-12"><p> And this was a different Mac Pro in more ways than its processor. Where the original 2006 model took some time to become a classic, it&#39;s deeply unlikely that the 2023 edition will.</p></div><div class="col-sm-12"><p> It&#39;s a <a href="https://appleinsider.com/articles/23/06/20/mac-pro-m2-review---maybe-a-true-modular-mac-will-come-in-a-few-more-years">fine Mac</a> , it is officially the top of the range, but in the three years it took to transition to Apple Silicon, every other Mac got there first — and that includes a brand-new one. The Mac Studio came out <a href="https://appleinsider.com/articles/22/03/22/mac-studio-with-m1-uitra-review-a-look-at-the-future-power-of-apple-silicon">in 2022</a> as the first entirely new Mac in years, and then it was updated <a href="https://appleinsider.com/articles/23/06/05/mac-studio-gets-updated-with-powerful-m2-max-and-m2-ultra-processors">in 2023</a> , right alongside the launch of the Mac Pro.</p></div><div class="col-sm-12"><p> The Mac Studio is like an extruded Mac mini in that it has the same base and just a taller chassis. No one expects the Mac Studio to be very expandable, so the fact that it comes with many ports — and that they are well-positioned to be easily accessible — is a bonus.</p></div><div class="col-sm-12"><p> Whereas the Apple Silicon Mac Pro may boast modularity, may come in a chassis that allows for expansion cards, but there are <a href="https://appleinsider.com/articles/23/06/05/apple-silicon-mac-pro-does-not-support-pci-e-radeon-video-cards">severe limits</a> on what those cards can be.</p></div><div class="col-sm-12"><p> And the killer fact that will surely stop the new Mac Pro becoming beloved is that it doesn&#39;t outperform the new Mac Studio.</p></div><div class="col-sm-12"><h2 data-anchor="back-to-the-future" id="back-to-the-future"> Back to the future</h2></div><div class="col-sm-12"><p> That original 2006 Mac Pro was the right combination of power, features, and upgradeability. The 2013 version ditched the upgradeable side, and then the 2019 version brought it back.</p></div><div class="col-sm-12"><p> The Apple Silicon Mac Pro comes somewhere in the middle for modularity and expandability.</p></div><div class="col-sm-12"><p> It does also come in at a far lower price than before, though. Where it was quite simple to buy a 2019 Mac Pro configuration that cost over $50,000, a maxed-out 2023 Apple Silicon Mac Pro is around $10,000.</p></div><div class="col-sm-12"><p> So it could be popular with its intended audience as it does represent much more performance at a vastly lower price. It&#39;s just that the Mac Studio matches that performance and is significantly cheaper.</p></div><div class="col-sm-12"><p> It&#39;s possible, then, that the original cheesegrater Mac Pro may be an example of catching lightning in a bottle.</p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><p></p> ]]>;</description><pubDate> Mon, 07 Aug 2023 10:32:22 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/articles/22/08/07/the-cheesegrater-mac-pro-is-16-year-old-and-still-the-best-mac-ever-made----for-now</guid><link/> https://appleinsider.com/articles/22/08/07/the-cheesegrater-mac-pro-is-16-year-old-and-still-the-best-mac-ever-made----for-now <author><![CDATA[William Gallagher]]></author></item><item><title><![CDATA[Understanding MetalKit: Getting started with Apple's graphics framework]]></title><description><![CDATA[<div class="col-sm-12"><div class="align-center"></div></div><div class="col-sm-12"><h2 data-anchor="getting-started" id="getting-started">入门</h2></div><div class="col-sm-12"><p>Metal is Apple&#39;s 3D graphics and game pipeline to render 3D objects on Apple devices. Designed to replace OpenGL and other 3D frameworks Metal has the advantage of being optimized for Apple hardware to achieve maximum performance.</p></div><div class="col-sm-12"><p> Apple provides buttery-smooth 3D rendering on Apple devices at performance levels not possible with other 3D frameworks.</p></div><div class="col-sm-12"><p> You have probably seen an example of Metal rendering on an iOS or <a href="https://appleinsider.com/inside/macos" title="苹果系统" data-kpt="1">macOS</a> device if you&#39;ve subscribed to and run Apple&#39;s Arcade game app. The brief introduction animation in Arcade is rendered with Metal: </p></div><div class="col-sm-12"><div class="primis-ad-wrap"></div></div><div class="col-sm-12"><div class="align-center"> <a href="https://photos5.appleinsider.com/gallery/55525-112889-metal-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112889-metal-xl.jpg" alt="Apple Arcade app intro rendered using Metal." height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div></div><div class="col-sm-12"><p> In 2015 at <a href="https://appleinsider.com/inside/wwdc" title="全球开发者大会" data-kpt="1">WWDC</a> , Apple introduced another, higher-level framework for Metal called MetalKit. This framework makes it easier to use Metal by providing some higher-level functions which make 3D app development simpler.</p></div><div class="col-sm-12"><p> Specifically, MetalKit provides additional Metal APIs in the following areas:</p></div><div class="col-sm-12"><ol> Texture loading Model I/O View management</ol></div><div class="col-sm-12"><h2 data-anchor="texture-loading" id="texture-loading"> Texture loading</h2></div><div class="col-sm-12"><p> Using MetalKit, asset and texture loading is easier by using the <code>MTKTextureLoader</code> class. This class provides an easy way to load assets and textures as well as set texture options.</p></div><div class="col-sm-12"><p> These options include <em>mipmap</em> usage and loading, cache and storage modes, texture coordinate transformation, cube texture usage, and RGB color options.</p></div><div class="col-sm-12"><p> A mipmap (or MIP map) is just a multi-layered image with each layer being a progressively lower resolution than the preceding layer. Mipmaps are used to speed image rendering and remove aliasing artifacts such as Moire patterns.</p></div><div class="col-sm-12"><p> A Moire pattern is a distracting banding or color artifact pattern that sometimes appears in computer graphics consisting of lines or regular pixel patterns such as alternating pixel grids:</p></div><div class="col-sm-12"><div class="align-center"> <a href="https://photos5.appleinsider.com/gallery/55525-112879-moire-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112879-moire-xl.jpg" alt="A Moire pattern." height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">A Moire pattern.</span></div></div><div class="col-sm-12"><p> Full documentation for MTKTextureLoader is available on Apple&#39;s developer website in the Metal framework documentation at Documentation/MetalKit/MTKTextureLoader.</p></div><div class="col-sm-12"><h2 data-anchor="model-io" id="model-io"> Model I/O</h2></div><div class="col-sm-12"><p> Model I/O is Apple&#39;s developer framework for managing 3D and 2D assets. MetalKit&#39;s Model I/O integration includes APIs for quickly loading textures into Metal buffers and use mesh data using containers.</p></div><div class="col-sm-12"><p> There are currently about a half-dozen Model I/O-related classes in MetalKit, mostly dealing with meshes. (We&#39;ll get to classes and object-oriented programming in a minute).</p></div><div class="col-sm-12"><h2 data-anchor="view-management" id="view-management"> View management</h2></div><div class="col-sm-12"><p> Most <a href="https://appleinsider.com/inside/ios" title="iOS系统" data-kpt="1">iOS</a> and macOS apps use <em>views</em> - standard classes that present visual information and UI elements on-screen. Different view subclasses provide different types of views.</p></div><div class="col-sm-12"><p> For example, in iOS a UIView is the view base class, but UIButton is a button view class derived from UIView. By using object-oriented view classes in iOS or macOS, you can build additional functionality which relies on standard functionality already defined by Apple classes.</p></div><div class="col-sm-12"><p> This is known as <em>object inheritance</em> . Think of an object in an app as a bundle of code that encapsulates both code and data that code operates on. By bundling both together into objects, code can be easily reused and repurposed by additional objects.</p></div><div class="col-sm-12"><p> In particular in MetalKit, a new class - MTKView - is provided which allows developers to create fully-fledged Metal views in apps. By having a dedicated Metal view class, the view can be drawn and managed optimally by Metal without any additional code.</p></div><div class="col-sm-12"><p> Apple&#39;s documentation for MTKView is on the developer website at Documentation/MetalKit/MTKView. MTKView also requires you to first set an MTLDevice in one of its properties to tell it which device and screen to render Metal objects into.</p></div><div class="col-sm-12"><p> MTKView also provides an MTLRenderPassDescriptor when asked which you can render your textures into. Check out the Documentation/Metal/Render Passes section of Apple&#39;s developer site.</p></div><div class="col-sm-12"><h2 data-anchor="a-little-oop" id="a-little-oop"> A little OOP</h2></div><div class="col-sm-12"><p> In <em>Object-Oriented Programming</em> (OOP), objects are defined by <em>classes</em> . A class is a definition in a source code file that defines what an object contains, and in <a href="https://appleinsider.com/inside/swift" title="迅速" data-kpt="1">Swift</a> , the actual implementation of an object.</p></div><div class="col-sm-12"><p> A class defines methods (functions) that can receive <em>messages</em> sent to them by other objects to perform some function. Each method contains code to perform some work.</p></div><div class="col-sm-12"><p> A class also defines <em>properties</em> or variables that can contain data. Typically a class&#39;s methods perform some work on the class&#39;s properties. Most, but not all methods can read most (but not all) properties contained in the class or in one of its <em>superclasses</em> (parent classes).</p></div><div class="col-sm-12"><p> All of the above is known as object <em>encapsulation</em> . Objects encapsulate both data and methods to keep everything tidy and organized. It&#39;s easier to transport, reference, copy, and use objects with their associated data in one place than it is to have to keep track of the data separately.</p></div><div class="col-sm-12"><p> <em>Inheritance</em> is an OOP feature by which new classes can be defined from another class. The derived object is called a <em>subclass</em> and the parent class is called the <em>superclass</em> .</p></div><div class="col-sm-12"><p> Long chains of objects can be defined by subclassing. Inheritance is powerful because it allows you to reuse existing code with almost no work.</p></div><div class="col-sm-12"><p> Subclasses inherit all the behavior and properties of their parent classes with almost no additional work. Subclasses can add additional methods only they (or their subclasses) know about.</p></div><div class="col-sm-12"><p> Even better, when you <em>instantiate</em> (create) an <em>instance</em> (one copy) of an object in a program it also instantiates a copy of all its superclass objects <em>automatically</em> .</p></div><div class="col-sm-12"><p> With one line of code, you can gain vast levels of program functionality just by creating one instance of a class.</p></div><div class="col-sm-12"><p> Instantiation is simply creating an object, allocating memory for it in RAM, and making it available to a program.</p></div><div class="col-sm-12"><p> All of this is usually defined in one or, in the case of Objective-C, two source code files - usually one or two files per class.</p></div><div class="col-sm-12"><p> So in our discussion above, an MTKView is defined as a class (by Apple) and is instantiated when created in code (by you). The result is an MTKView object in memory, ready for use. When the MTKView object is no longer needed, it is <em>de-allocated</em> which removes it from memory, destroying it.</p></div><div class="col-sm-12"><p> Most apps are programs that create, use, manage, and destroy hundreds of such objects.</p></div><div class="col-sm-12"><p> The OOP programming paradigm is powerful because it vastly reduces the amount of code needed via subclassing and <em>reuse</em> , and keeps programs more modular and reusable by encapsulating code and data.</p></div><div class="col-sm-12"><p> Once you&#39;ve written a class to do some specific work, you can simply reuse the class or subclass it in another program to create another app quickly. </p></div><div class="col-sm-12"><h2 data-anchor="core-animation-in-metalkit" id="core-animation-in-metalkit">Core Animation in MetalKit</h2></div><div class="col-sm-12"><p> Like many iOS or macOS standard views, MTKView also has a <em>Core Animation Layer</em> . Core Animation is Apple&#39;s high-performance 2D animation framework.</p></div><div class="col-sm-12"><p> Most views have a <em>CALayer</em> - a Core Animation layer object which can draw and animate 2D graphics. CALayers can be grouped and combined to create complex animations.</p></div><div class="col-sm-12"><p> MTKView has its own CALayer subclass called CAMetalLayer which Metal can render into. You can combine CAMetalLayer with other CA layers to create combined 2D and 3D animations.</p></div><div class="col-sm-12"><p> In most cases for both 2D and 3D CALayers, drawing is much faster and more efficient than the drawing that occurs in UIViews. You can also set the opacity, or <em>alpha</em> of CA layers to make parts of them transparent.</p></div><div class="col-sm-12"><h2 data-anchor="mtkview-modes" id="mtkview-modes"> MTKView modes</h2></div><div class="col-sm-12"><p> MTKView supports three modes of drawing:</p></div><div class="col-sm-12"><ol> Timed Notifications Explicit</ol></div><div class="col-sm-12"><p> In Timed drawing the view updates at regular intervals set internally in the object. Most games use this mode when a game scene is rendered or drawn at a specific rate described in frames per second (fps).</p></div><div class="col-sm-12"><p> With Timed mode, you can also set or clear the <code>isPaused</code> property to start and stop the view animation.</p></div><div class="col-sm-12"><p> In Notification mode, redraw happens when some part of all of the view becomes invalidated. This allows you to redraw just a portion of the view or layer - which takes less time and improves game performance.</p></div><div class="col-sm-12"><p> To force a redraw using Notification mode simply send the view object a setNeedsDisplay() message to force it to redraw. This forces the view to redraw all its subviews by sending them each a setNeedsDisplay() message also.</p></div><div class="col-sm-12"><p> In Explicit drawing, you redraw view content by sending the view object a draw() message directly. This is generally discouraged unless you have some custom drawing workflow you use that does something outside the standard view/subview hierarchy.</p></div><div class="col-sm-12"><p> You can also redraw only parts of a view by sending their subviews setNeedsDisplay() message also, thereby bypassing the top-level view redraw. In general, the fewer objects that get redrawn, the better the performance.</p></div><div class="col-sm-12"><p> In the case of an MTKView or a subclass thereof, in your drawing method, you obtain an MTLRenderPassDescriptor from the view, render into it, then present the resulting <em>drawable</em> for display.</p></div><div class="col-sm-12"><p> A drawable is any Metal object which has been encoded and is ready to be displayed.</p></div><div class="col-sm-12"><h2 data-anchor="mtkviewdelegate" id="mtkviewdelegate"> MTKViewDelegate</h2></div><div class="col-sm-12"><p> In Apple&#39;s Swift and Objective-C programming languages, a <em>delegate</em> is an object that performs some work on behalf of another object.</p></div><div class="col-sm-12"><p> Usually, one object will declare a delegate object as one of its properties, and the delegate declares which methods (functions) it provides.</p></div><div class="col-sm-12"><p> Delegates are powerful because you can change the behavior of an object simply by changing its delegate property. Delegates are also used to provide additional functionality to objects without having to subclass an object to create another object.</p></div><div class="col-sm-12"><p> <code>MTKView</code> has its own delegate object called <code>MTKViewDelegate</code> class also described in Apple&#39;s documentation. <code>MTKViewDelegate</code> mostly responds to view redraw and resize events.</p></div><div class="col-sm-12"><p> <code>MTKViewDelegate</code> also inherits from a standard Objective-C protocol common to all Apple objects called <em>NSObjectProtocol</em> .</p></div><div class="col-sm-12"><p> Think of delegates and protocols as additional objects and methods which can be attached to or &quot;glued&quot; onto other objects.</p></div><div class="col-sm-12"><p> In Objective-C and Swift, a <em>protocol</em> is simply a list of additional methods a class must implement. The contents of each method in a protocol are up to each class to define.</p></div><div class="col-sm-12"><p> The <code>MTKViewDelegate</code> is mostly concerned with changing a view&#39;s layout (on device rotation, for example), and drawing.</p></div><div class="col-sm-12"><p> For example, you could define several <code>MTKViewDelegate</code> objects, each with a different behavior, then change your <code>MTKView</code> &#39;s drawing or rotation behavior simply by resetting its <code>delegate</code> property to any one of the delegate objects at will and redrawing.</p></div><div class="col-sm-12"><h2 data-anchor="rendering" id="rendering">渲染</h2></div><div class="col-sm-12"><p>When using <code>MTKView</code> , implement the methods of the <code>MTKViewDelegate</code> in your renderer. This allows your renderer to interact with the <code>MTKView</code> and provide drawing and layout changes.</p></div><div class="col-sm-12"><p> You can obtain info when it is time to render each frame by using the MTKView&#39;s <code>currentRenderPassDescriptor</code> property. This allows you to interact with each frame to be rendered.</p></div><div class="col-sm-12"><p> For example in Swift:</p></div><div class="col-sm-12"><p> <code>if let onscreenDescriptor = view.currentRenderPassDescriptor</code></p></div><div class="col-sm-12"><p> This gets the <code>MTKView</code> &#39;s current render pass descriptor and stores it in a variable called <code>onscreenDescriptor</code> .</p></div><div class="col-sm-12"><p> After rendering, you must use the drawable to update the view&#39;s contents. To do so call the present(_:) method on the <code>MTLCommandBuffer</code> object, then send the <code>commit()</code> message and the command buffer to the GPU for display.</p></div><div class="col-sm-12"><p> There&#39;s a more detailed discussion of this process in the <code>MTKView</code> &#39;s documentation.</p></div><div class="col-sm-12"><h2 data-anchor="simd" id="simd">单指令多数据流</h2></div><div class="col-sm-12"><p>Apple also has a math-related framework called <em>SIMD</em> which comes in handy when manipulating 3D and 2D objects and performing calculations on them and matrices. Most of these functions are used to perform fast, efficient floating point math prevalent in 3D calculations.</p></div><div class="col-sm-12"><p> SIMD can come in handy when you need to transform 3D objects and vertices on objects. The most common and useful data structure in SIMD is <code>simd_float4x4</code> , which is a four-by-four matrix of single-precision floating values. </p></div><div class="col-sm-12"><h2 data-anchor="tying-it-all-together-in-xcode" id="tying-it-all-together-in-xcode"> Tying it all together in Xcode</h2></div><div class="col-sm-12"><p> Armed with all this background knowledge, you&#39;re now ready to create a MetalKit app in <a href="https://appleinsider.com/inside/xcode" title="Xcode" data-kpt="1">Xcode</a> . In the following example, we&#39;ll assume you&#39;ll be creating a simple 3D app containing a single scene that contains a single Metal 3D object.</p></div><div class="col-sm-12"><p> To write an Xcode MetalKit app you&#39;ll need to be familiar with Apple&#39;s Swift and Objective-C programming languages, and a little bit of ANSI-C - an earlier C-only language invented at Bell Labs in 1972 when UNIX was created.</p></div><div class="col-sm-12"><p> To get started open Xcode, and select <strong>File->;New Project</strong> from the File menu. From the project template chooser, choose <strong>iOS</strong> or <strong>macOS</strong> at the top, then choose <strong>Game</strong> from the icons below and click <strong>Next</strong> :</p></div><div class="col-sm-12"><div class="align-center"> <a href="https://photos5.appleinsider.com/gallery/55525-112880-xcode-1-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112880-xcode-1-xl.jpg" alt="Chose the" game="" template.="" height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Chose the &quot;Game&quot; template.</span></div></div><div class="col-sm-12"><p> On the next pane enter an app name, bundle ID, and organization info and select <strong>Swift</strong> and <strong>Metal</strong> from the two lower popup menus:</p></div><div class="col-sm-12"><div class="align-center"> <a href="https://photos5.appleinsider.com/gallery/55525-112881-xcode-2-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112881-xcode-2-xl.jpg" alt="输入项目详细信息。" height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Enter project details.</span></div></div><div class="col-sm-12"><p> Click <strong>Next</strong> and save your new Xcode project to disk.</p></div><div class="col-sm-12"><p> You&#39;ll also need to define a texture image for your 3D object as a .png file and add it to your Xcode project. This texture file gets &quot;wrapped&quot; onto your 3D object at render time.</p></div><div class="col-sm-12"><p> Xcode&#39;s Metal game template app provides the minimal default template source files you&#39;ll need for your app, but first, you&#39;ll need to add the Metal frameworks to tell Xcode to link those frameworks to your app at runtime.</p></div><div class="col-sm-12"><p> To do so, in the Xcode project editor select the name of your project by selecting the project icon in the upper left corner of the project window, then select the target name to the right of that under the Targets section:</p></div><div class="col-sm-12"><div class="align-center"><a href="https://photos5.appleinsider.com/gallery/55525-112882-Screenshot-3-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112882-Screenshot-3-xl.jpg" alt="选择目标。" height="621" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Select the target.</span></div></div><div class="col-sm-12"><p> Scroll to the bottom of the window and under the &quot;Frameworks, Libraries, and Embedded Content&quot; section, click the <strong>&quot;+&quot;</strong> button. The framework selection pane will appear.</p></div><div class="col-sm-12"><div class="align-center"><a href="https://photos5.appleinsider.com/gallery/55525-112884-Screenshot-2-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112884-Screenshot-2-xl.jpg" alt="点击" button.="" height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Click the &quot;+&quot; button.</span></div></div><div class="col-sm-12"><p> Type &quot;metal&quot; in the search box at the top, and Command-click on six of the seven frameworks listed, excluding the &quot;MetalFX.framework&quot;. There are hundreds of Xcode frameworks available.</p></div><div class="col-sm-12"><div class="align-center"> <a href="https://photos5.appleinsider.com/gallery/55525-112883-Screenshot-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112883-Screenshot-xl.jpg" alt="添加框架表。" height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Add framework sheet.</span></div></div><div class="col-sm-12"><p> You&#39;ll also want to add the libswiftsimd.tbd library, Core Services frameworks, and optionally the Accelerate framework.</p></div><div class="col-sm-12"><p> &quot;tbd&quot; is a placeholder for <em>&quot;To be determined&quot;</em> as the version numbers of the actual code libraries can change. Including a .tbd library in Xcode tells Xcode to use the <em>most recent</em> version of that library.</p></div><div class="col-sm-12"><p> If you want to use Model I/O to manage assets, also add &quot;libswiftModelIO.tbd&quot; and &quot;ModelIO.framework&quot;.</p></div><div class="col-sm-12"><p> If you created an iOS app in the template chooser, also add UIKit.framework. If you created a macOS app in the template chooser, also add Cocoa.framework.</p></div><div class="col-sm-12"><p> Finally, include the Foundation.framework and CoreFoundation.framework. Foundation is a core C-language framework that most iOS and macOS apps use. All Foundation API calls are in plain C.</p></div><div class="col-sm-12"><h2 data-anchor="shaders" id="shaders"> Shaders</h2></div><div class="col-sm-12"><p> Complete code for a Metal game app is beyond the scope of this article so we&#39;ll briefly cover just the basics here for our one-object example. Apple&#39;s sample project template creates a single 3D cube that rotates in space.</p></div><div class="col-sm-12"><p> Xcode creates an app delegate file that controls the general event loop of the app itself, and a <code>ShaderTypes.h</code> file which is a header file defining the shader&#39;s mesh and vertex info along with a C struct defining the projection matrix and model view matrix.</p></div><div class="col-sm-12"><p> These are used by the shader when drawing.</p></div><div class="col-sm-12"><p> The &quot;Shaders.metal&quot; file imports the &quot;ShaderTypes.h&quot; header file defined above which is shared between the renderer and the GameViewController.swift file which we&#39;ll get it in a moment. You import header files into other Swift or Objective-C source code files using the <code>import</code> preprocessor directive:</p></div><div class="col-sm-12"><p> <code>#import &quot;ShaderTypes.h&quot;</code></p></div><div class="col-sm-12"><p> Preprocessor directives are compiler instructions that run <em>prior</em> to actual compilation and usually begin with a &quot;#&quot; sign.</p></div><div class="col-sm-12"><p> &quot;Shaders.metal&quot; also imports two other files, <code>metal_stdlib</code> and <code>simd.h</code> using the earlier ANSI-C import directive <code>#include</code> . Both #import and #include are similar and we won&#39;t get into the detailed differences between the two here.</p></div><div class="col-sm-12"><p> Below that you&#39;ll see this line:</p></div><div class="col-sm-12"><p> <code>using namespace metal;</code></p></div><div class="col-sm-12"><p> <em>Namespaces</em> are a C++ idiom that allows similar or identical sections of code to be defined and isolated by defining them under a namespace. Each namespace has its own name, in this case <code>metal</code> .</p></div><div class="col-sm-12"><p> In Shaders.metal you define a <code>Vertex</code> and <code>ColorInOut</code> structure, and several functions which define the shaders - in this case only a vertex shader and fragment shader. The fragment shader also contains a sampler variable which allows you to define and use mipmaps if you wish.</p></div><div class="col-sm-12"><p> The <code>fragmentShader</code> function takes as its arguments color information, a <code>Uniforms</code> structure defined in SharderTypes.h, and a <code>texture2d</code> as defined in the Metal library header &quot;metal_texture&quot;.</p></div><div class="col-sm-12"><p> The <code>Uniforms</code> parameter contains, as previously discussed, the projection matrix and the model view matrix.</p></div><div class="col-sm-12"><h2 data-anchor="renderer" id="renderer"> Renderer</h2></div><div class="col-sm-12"><p> The next file, Renderer.swift defines the object&#39;s <code>Renderer</code> class which inherits from the base Objective-C class, <code>NSObject</code> and conforms to the <code>MTKViewDelegate</code> protocol.</p></div><div class="col-sm-12"><p> As a bit of a historical note, NSObject harkens all the way back to the NeXT Computer days - <a href="https://appleinsider.com/inside/steve-jobs" title="史蒂夫·乔布斯" data-kpt="1">Steve Jobs</a> &#39; second company after he was fired from Apple in 1985. NeXT invented Objective-C and had an OS and framework called <em>NeXTStep</em> . The &quot;NS&quot; in <code>NSObject</code> stands for &quot;NeXTStep&quot;.</p></div><div class="col-sm-12"><p> Most early NeXTStep objects had the prefix &quot;NS&quot; to differentiate them from third-party objects. When Apple bought NeXT Computer Inc. in 1997 it acquired all of NeXT&#39;s technology, including NeXTStep.</p></div><div class="col-sm-12"><p> To this day macOS and iOS are based on NeXTStep.</p></div><div class="col-sm-12"><p> Properties of the Renderer class include a MTLDevice, MTLCommandQueue, MTLBuffer, MTLRenderPipelineState, MTLDepthStencilState, and MTLTexture as well as properties for the matrices, rotation, mesh, and a semaphore.</p></div><div class="col-sm-12"><p> A <em>semaphore</em> is a thread (path of execution) that relies on a flag to tell it when it can run and when it can&#39;t.</p></div><div class="col-sm-12"><p> When you instantiate a <code>Render</code> object, you pass it an <code>MTKView</code> in its <code>init</code> method, which we&#39;ll get to in a moment.</p></div><div class="col-sm-12"><p> As soon as the object is created, its <code>init</code> method runs, and all the code in that method runs.</p></div><div class="col-sm-12"><p> The <code>init</code> method sets up and assigns all its properties at the top of the method, then creates a render buffer via the self.device.makeBuffer() line.</p></div><div class="col-sm-12"><p> Then it sets a few properties on the metalKitView passed in to the <code>init</code> method, creates a vertex descriptor via <code>Renderer.buildMetalVertexDescriptor()</code> , and then builds the render pipeline via <code>Renderer.buildRenderPipelineWithDevice()</code> .</p></div><div class="col-sm-12"><p> Next, the code creates depth and stencil info, and then creates a mesh via <code>Renderer.buildMesh</code> .</p></div><div class="col-sm-12"><p> Finally, it builds a color map and texture via <code>Renderer.loadTexture()</code> .</p></div><div class="col-sm-12"><p> You&#39;ll need to use the Renderer&#39;s texture loader method, <code>loadTexture:device:textureName:</code> to load your texture from the .png file you created above - passing the method your texture&#39;s filename - in this example <code>&quot;ColorMap&quot;</code> .</p></div><div class="col-sm-12"><p> The <code>do/catch</code> Swift construct is for error handling. The code contained in <code>do</code> is attempted and if it fails, the <code>catch</code> block is run, else program execution continues normally. </p></div><div class="col-sm-12"><h2 data-anchor="the-superclasss-init-method" id="the-superclasss-init-method"> The superclass&#39;s init() method</h2></div><div class="col-sm-12"><p> Finally at the end of the Renderer&#39;s <code>init</code> method the <em>superclass&#39;s</em> <code>init</code> method is run:</p></div><div class="col-sm-12"><p> <code>super.init()</code></p></div><div class="col-sm-12"><p> Sending the <code>super.init()</code> message to the superclass at the end of a Swift class&#39;s <code>init</code> method ensures the entire chain of objects in the class hierarchy gets created. This is a standard pattern in Swift and Objective-C.</p></div><div class="col-sm-12"><p> If you fail to call a superclass&#39;s <code>init</code> method, it&#39;s highly likely the object will crash, or at best not function properly - or your app itself will crash.</p></div><div class="col-sm-12"><p> Since subclasses rely on superclass methods while running, if the superclass object doesn&#39;t exist, a subclass&#39;s method call may be sent off into random memory space where the code it is expecting doesn&#39;t exist.</p></div><div class="col-sm-12"><p> When that happens and the processor tries to execute the code at that memory location, a crash is certain - there&#39;s no code there to run.</p></div><div class="col-sm-12"><p> <code>super.init()</code> is usually called <em>last</em> in Swift and Objective-C in order to give your object time to do any setup it needs before the superclass object is set up.</p></div><div class="col-sm-12"><p> Finally, the Renderer&#39;s <code>init</code> method ends with the closing &quot;}&quot; brace.</p></div><div class="col-sm-12"><h2 data-anchor="renderer-methods" id="renderer-methods"> Renderer methods</h2></div><div class="col-sm-12"><p> Immediately after the <code>init()</code> method in Renderer.swift are the actual implementations of the other methods in the Renderer class. Each Swift function is prefixed with <code>class func</code> followed by the function name, and any function parameters in parenthesis.</p></div><div class="col-sm-12"><p> If a Swift method returns a value upon completion, that return value type is defined by the <code>->;</code> construct.例如：</p></div><div class="col-sm-12"><p> <code>class func buildMetalVertexDescriptor() ->; MTLVertexDescriptor</code> defines a method (function) named <code>buildMetalVertexDescriptor</code> which returns a <code>MTLVertexDescriptor</code> on successful completion. This is called the <em>return value</em> or return type.</p></div><div class="col-sm-12"><p> As we saw previously the <code>buildMetalVertexDescriptor</code> method is called <em>internally</em> on object instantiation from the <code>init()</code> method. Many objects work this way.</p></div><div class="col-sm-12"><p> But most methods can also be called from external objects unless a class definition explicitly prohibits it.</p></div><div class="col-sm-12"><h2 data-anchor="game-loop" id="game-loop"> Game loop</h2></div><div class="col-sm-12"><p> The Renderer game loop drives most Metal games, along with the Renderer and MTKView&#39;s <code>draw</code> methods. This combined with the main event loop monitored in the application delegate object drives the app as it is running on a device.</p></div><div class="col-sm-12"><p> In the Render.swift file you&#39;ll notice a method named <code>private func updateGameState()</code> this method can be run periodically to update any state stored in the game such as object positions, mouse, keyboard, or game controller inputs, position, timing, scores, etc.</p></div><div class="col-sm-12"><p> The Swift keyword <code>private</code> means this method is private to and can only be called from this object and any extensions defined in this source file only - external objects can&#39;t send that message to the Renderer object.</p></div><div class="col-sm-12"><p> This additional access control ensures correct program execution only from within and by certain objects - in this case since the Renderer is responsible for the general execution and control of the game, you wouldn&#39;t want any external object interfering with it.</p></div><div class="col-sm-12"><p> Apple has an entire object Access Control section in the Swift developer documentation on the <a href="https://docs.swift.org/">Swift Documentation</a> website.</p></div><div class="col-sm-12"><h2 data-anchor="frame-rendering" id="frame-rendering"> Frame rendering</h2></div><div class="col-sm-12"><p> Next in Renderer.swift, we see the <code>draw()</code> method:</p></div><div class="col-sm-12"><p> <code>func draw(in view: MTKView)</code></p></div><div class="col-sm-12"><p> You pass in the MTKView you want the drawing done into. Note this function has no return value. Such functions in Swift and Objective-C are called void functions.</p></div><div class="col-sm-12"><p> In the <code>draw()</code> method, which gets called once per frame, the semaphore is told to wait for a certain amount of time:</p></div><div class="col-sm-12"><p> <code>inFlightSemaphore.wait()</code></p></div><div class="col-sm-12"><p> Then the command buffer is created and sent to the semaphore for rendering, adding a <em>completion handler</em> .</p></div><div class="col-sm-12"><p> A <em>completion handler</em> is a function that gets run automatically when some other tasks or thread finishes. Completion handlers are a way of executing code in a sequential manner but only when some other section of code finishes.</p></div><div class="col-sm-12"><p> Completion handlers provide guaranteed execution of code, but without having to write code to manage complex timer algorithms and wait conditions.</p></div><div class="col-sm-12"><p> Next, the 3D object buffers and game state are updated in that order:</p></div><div class="col-sm-12"><p> <code>self.updateDynamicBufferState()</code></p></div><div class="col-sm-12"><p> <code>self.updateGameState()</code></p></div><div class="col-sm-12"><p> Next, a render pass descriptor is obtained from the <code>MTKView</code> and the render pass encoder properties are updated:</p></div><div class="col-sm-12"><p> <code>let renderPassDescriptor = view.currentRenderPassDescriptor</code></p></div><div class="col-sm-12"><p> Then a short loop runs to get the mesh vertex descriptor layouts and buffers and store them in the render encoder. Then the render encoder&#39;s fragment texture info is set:</p></div><div class="col-sm-12"><p> <code>renderEncoder.setFragmentTexture(colorMap, index: TextureIndex.color.rawValue)</code></p></div><div class="col-sm-12"><p> Next, for each mesh (object) in the <code>.submeshes</code> array, <code>renderEncoder.drawIndexedPrimitives()</code> is called. This is where each object in the scene is encoded.</p></div><div class="col-sm-12"><p> To end the encoding phase <code>renderEncoder.endEncoding()</code> is called. The objects are now all ready to be drawn.</p></div><div class="col-sm-12"><p> The view&#39;s drawable is then obtained via:</p></div><div class="col-sm-12"><p> <code>if let drawable = view.currentDrawable</code></p></div><div class="col-sm-12"><p> and if successful, the entire command buffer is then drawn with:</p></div><div class="col-sm-12"><p> <code>commandBuffer.commit()</code></p></div><div class="col-sm-12"><p> The call to <code>commit</code> actually sends the scene&#39;s frame to the GPU for display onscreen.</p></div><div class="col-sm-12"><p> All of the above happens at thirty, sixty, or one-hundred twenty fps.</p></div><div class="col-sm-12"><p> The Renderer.swift file ends with a few general 3D math transformations and rotation functions. </p></div><div class="col-sm-12"><h2 data-anchor="displaying-the-scene-in-a-view-onscreen" id="displaying-the-scene-in-a-view-onscreen"> Displaying the scene in a view onscreen</h2></div><div class="col-sm-12"><p> You will notice two additional files in the Xcode project: GameViewController.swift and Main.storyboard. These are typical files found in most iOS apps.</p></div><div class="col-sm-12"><p> A typical iOS app contains a central top-level <code>UIViewController</code> class defined in the UIKIt framework. A <code>UIViewController</code> is a class that manages and controls another UIKIt class - <code>UIView</code> .</p></div><div class="col-sm-12"><p> A <code>UIView</code> class is a class that contains other <code>UIView</code> subclasses such as buttons, images, text, and other UIKIt objects. <code>UIView</code> is how an iOS app&#39;s user interface is represented onscreen.</p></div><div class="col-sm-12"><p> Every <code>UIViewController</code> class has a property named <code>view</code> which is an instance of <code>UIView</code> . The view controller manages the <code>UIView</code> .</p></div><div class="col-sm-12"><p> If you look at Apple&#39;s documentation for <code>UIViewController</code> , you&#39;ll notice a half dozen methods for managing the view - namely methods for loading the view, being notified when the view loads, and unloading views.</p></div><div class="col-sm-12"><p> In most iOS apps, you don&#39;t load the top-level view directly - you load it by instantiating a <code>UIViewController</code> subclass you define (in this example a <code>GameViewController</code> ). The user interface part of the view is created in Xcode&#39;s Interface Builder editor, or via a text-only SwiftUI view.</p></div><div class="col-sm-12"><p> Typically when creating an iOS app, you lay out each view in Interface Builder by dragging visual components from the Xcode library and dropping them into a view controller object onscreen.</p></div><div class="col-sm-12"><p> Once your UI objects are all laid out onscreen you connect them to a view controller&#39;s properties via a Control-click and drag from each UI element to the view controller&#39;s <em>first responder</em> . A first responder is the first object in a view controller object hierarchy that is capable of responding to that object&#39;s messages.</p></div><div class="col-sm-12"><p> When you release the mouse button from your Control-click and drag above, Xcode displays a list of available object properties to connect the object to.</p></div><div class="col-sm-12"><p> That&#39;s it - you typically don&#39;t have to do any coding for each UI element - when the view controller gets instantiated and loaded into memory, the Swift or Objective-C runtime makes all the UI connections for you automatically.</p></div><div class="col-sm-12"><p> This vastly simplifies application development. </p></div><div class="col-sm-12"><h2 data-anchor="-storyboards-and-segues" id="-storyboards-and-segues">Storyboards and Segues</h2></div><div class="col-sm-12"><p> <em>Storyboard</em> files were later added to Xcode to simplify UI layout even further: with Storyboards you define <em>Segues</em> between view transitions - when users navigate between each view on the device, the Segue function you indicate gets called where you can then do any initial view setup or cleanup.</p></div><div class="col-sm-12"><p> Segues eliminate most view-loading code.</p></div><div class="col-sm-12"><h2 data-anchor="viewdidload" id="viewdidload"> viewDidLoad()</h2></div><div class="col-sm-12"><p> In any case when a view controller finishes loading a view, the controller&#39;s <code>viewDidLoad()</code> method gets called. It&#39;s in <code>viewDidLoad()</code> that you do any additional view setup you need. Once <code>viewDidLoad()</code> exits, the view is ready to use and is displayed onscreen to the user.</p></div><div class="col-sm-12"><p> You can subclass both <code>UIViewController</code> and <code>UIView</code> to make your views highly customizable. The one thing to remember is that most UI elements in iOS are stored as properties in a <code>UIViewController</code> subclass.</p></div><div class="col-sm-12"><p> It is possible to create views and view controllers entirely in code without a Storyboard or Interface Builder, but doing so is much more complex and time-consuming. </p></div><div class="col-sm-12"><h2 data-anchor="gameviewcontrollerswift" id="gameviewcontrollerswift">GameViewController.swift</h2></div><div class="col-sm-12"><p> Let&#39;s take a look at <code>GameViewController.swift</code></p></div><div class="col-sm-12"><p> The class is defined at the top of the file:</p></div><div class="col-sm-12"><p> <code>class GameViewController: UIViewController</code></p></div><div class="col-sm-12"><p> This means <code>GameViewController</code> is a subclass of <code>UIViewController</code> .</p></div><div class="col-sm-12"><p> The class definition is contained in matching open and closed brackets (&quot;{&quot;, and &quot;}&quot;).</p></div><div class="col-sm-12"><p> Note that the <code>GameViewController</code> class is very short - just over a page. Most of the game processing work happens in the shaders and renderers.</p></div><div class="col-sm-12"><p> Next, we see two Swift properties as defined by the <code>var</code> keyword:</p></div><div class="col-sm-12"><p> <code>var renderer: Renderer!</code></p></div><div class="col-sm-12"><p> <code>var mtkView: MTKView!</code></p></div><div class="col-sm-12"><p> Next we see that <code>GameViewController</code> overrides the <code>UIViewController</code> method <code>viewDidLoad()</code> using the Swift <code>override</code> keyword:</p></div><div class="col-sm-12"><p> <code>override func viewDidLoad()</code></p></div><div class="col-sm-12"><p> This means that when the view controller loads the view and sends the <code>viewDidLoad()</code> message, the <code>GameViewController</code> version of the method will be run instead of the <code>UIViewController</code> version. This is a perfect example of inheritance in action: you can choose to let a superclass&#39;s method run, or override it in a subclass and use that method instead.</p></div><div class="col-sm-12"><p> Note that in order for this to work, the declarations of both methods in both classes must be <em>identical</em> .</p></div><div class="col-sm-12"><p> The first thing the <code>override func viewDidLoad()</code> does is send the superclass ( <code>UIViewController</code> ) a <code>viewDidLoad()</code> message. This allows the <code>UIViewController</code> to do any UI view layout initialization it needs to do.</p></div><div class="col-sm-12"><p> Without this &quot;super&quot; call the view won&#39;t work correctly because some of its internal parts won&#39;t ever get initialized.</p></div><div class="col-sm-12"><p> Next, the <code>GameViewController</code> object loads the MTKView and stores it in its internal property <code>mtkView</code> :</p></div><div class="col-sm-12"><p> <code>guard let mtkView = view as? MTKView else</code></p></div><div class="col-sm-12"><p> <code>guard</code> is simply a Swift conditional test to see if something succeeded - similar to <code>if</code> .</p></div><div class="col-sm-12"><p> <code>GameViewController</code> then also stores a reference to the device&#39;s Metal device in its internal <code>defaultDevice</code> property.</p></div><div class="col-sm-12"><p> <code>guard let defaultDevice = MTLCreateSystemDefaultDevice() else</code></p></div><div class="col-sm-12"><p> The important thing to understand here is that the two internal properties or variables:</p></div><div class="col-sm-12"><p> <code>var renderer: Renderer!</code></p></div><div class="col-sm-12"><p> <code>var mtkView: MTKView!</code></p></div><div class="col-sm-12"><p> store references to other objects in memory - in this case the renderer and the Metal view. Once stored, the <code>GameViewController</code> object can access those objects at will. This pattern is how most objects work in Swift and Objective-C.</p></div><div class="col-sm-12"><p> In Objective-C these two properties would have been declared as:</p></div><div class="col-sm-12"><p> <code>Renderer *renderer = nil;</code></p></div><div class="col-sm-12"><p> <code>MTKView *mtkView = nil;</code></p></div><div class="col-sm-12"><p> <code>nil</code> is an Objective-C placeholder which means &quot;nothing&quot; or more specifically no address in memory. nil is used to indicate an Objective-C property or variable doesn&#39;t contain anything.</p></div><div class="col-sm-12"><p> The <code>&#39;*&#39;</code> is a standard indicator for a C or Objective-C <em>pointer</em> - a variable that holds a <em>memory address</em> to an object instead of a value. Pointers are complex subject so we won&#39;t get into them here.</p></div><div class="col-sm-12"><p> Also note that Objective-C and C code lines must end with a <code>&#39;;&#39;</code> (semicolon). This isn&#39;t optional - without the semicolon, the code won&#39;t compile and you&#39;ll get an error.</p></div><div class="col-sm-12"><p> Swift dropped semicolons (but you can actually still use them if you want).</p></div><div class="col-sm-12"><p> Next the <code>GameViewController</code> stores more references to other objects but this time inside the mtkView property object:</p></div><div class="col-sm-12"><p> <code>mtkView.device = defaultDevice</code></p></div><div class="col-sm-12"><p> <code>mtkView.backgroundColor = UIColor.black</code></p></div><div class="col-sm-12"><p> This means store the default rendering device in the mtkView.device property, and store a black UIColor in the tkView.backgroundColor.</p></div><div class="col-sm-12"><p> <code>UIColor</code> is a standard UIKit object to indicate color - in this case set to black, which will be used as the scene&#39;s background color. Every <code>UIColor</code> object has a <code>.backgroundColor</code> property.</p></div><div class="col-sm-12"><p> Note what you&#39;re actually doing here is storing references to objects in properties which are themselves properties of this class&#39;s properties. This is confusing at first but once you get the hang of it it&#39;s easy to understand.</p></div><div class="col-sm-12"><p> By chaining properties across objects, you&#39;re really just Dasiy-chaining objects together.</p></div><div class="col-sm-12"><p> You can have properties pointing to properties, pointing to other objects. There&#39;s theoretically no limit on how deep property references can go.</p></div><div class="col-sm-12"><p> Before you release (destroy) an object you should set all its properties to <code>nil</code> in the class&#39;s <code>deinit()</code> method to ensure all references to other objects get released. Failure to do so can result in <em>memory leaks</em> and unwanted <em>retain cycles</em> .</p></div><div class="col-sm-12"><p> In Objective-C <code>deinit()</code> is called <code>dealloc</code> .</p></div><div class="col-sm-12"><p> Continuing, the <code>Renderer</code> object is created, passing in the <code>MTKView</code> object and a reference (pointer) to the <code>Renderer</code> is stored in the view controller&#39;s <code>renderer</code> property:</p></div><div class="col-sm-12"><p> <code>guard let newRenderer = Renderer(metalKitView: mtkView) else</code></p></div><div class="col-sm-12"><p> <code>renderer = newRenderer</code></p></div><div class="col-sm-12"><p> First, you create the object, then you store a reference to it in a property.</p></div><div class="col-sm-12"><p> Then the <em>renderer&#39;s</em> pointer to the MTKView is sent the <code>drawableSizeWillChange</code> message:</p></div><div class="col-sm-12"><p> <code>renderer.mtkView(mtkView, drawableSizeWillChange: mtkView.drawableSize)</code></p></div><div class="col-sm-12"><p> This lets the renderer know what the view&#39;s current drawable size is so it knows how and where to scale the scene when it gets sent to the GPU. Note that the drawable size is stored in the <code>MTKView</code> already in its <code>.drawableSize</code> property.</p></div><div class="col-sm-12"><p> This demonstrates that you can pass an object&#39;s properties to methods as parameters.</p></div><div class="col-sm-12"><p> Finally, the view&#39;s delegate is set to the renderer itself:</p></div><div class="col-sm-12"><p> <code>mtkView.delegate = renderer</code></p></div><div class="col-sm-12"><p> Recall that in the <code>Renderer.swft</code> file the <code>Renderer</code> class is declared as conforming to the <code>MTKViewDelegate</code> protocol:</p></div><div class="col-sm-12"><p> <code>class Renderer: NSObject, MTKViewDelegate</code></p></div><div class="col-sm-12"><p> This is what allows the <code>mtkView.delegate</code> property to be set to a <code>Renderer</code> object. Without the <code>MTKViewDelegate</code> protocol conformance in the <code>Renderer</code> class definition, the <code>mtkView.delegate = renderer</code> line would likely throw a warning or error when compiled saying that the <code>renderer</code> property doesn&#39;t conform to the <code>MTKViewDelegate</code> protocol.</p></div><div class="col-sm-12"><p> Also note that one critical gotcha for newcomers to Xcode is that <em>before</em> you destroy a view controller object you must first set its <code>.delegate</code> property to <code>nil</code> . Failure to do so will guarantee your app will crash.</p></div><div class="col-sm-12"><p> This in fact applies to any Swift or Objective-C object which contains delegates - not just to view controllers.</p></div><div class="col-sm-12"><p>为什么？ Because if you don&#39;t release the reference stored in the delegate property first, between the time the containing object actually disappears from memory and the time the system realizes the object has been destroyed, some <em>other</em> object may have sent the <em>delegate</em> object <em>another</em> message.</p></div><div class="col-sm-12"><p> Not realizing the object which contained the delegate property no longer exists, the message sent to the delegate may still be waiting to be processed - and when it does get processed the delegate is now invalid because its containing object no longer exists.</p></div><div class="col-sm-12"><p> The delegate gets left dangling in memory but its containing object is long gone - and the system thus has no way to locate the delegate object the message is bound for.</p></div><div class="col-sm-12"><p> Boom - a crash.</p></div><div class="col-sm-12"><p> Sending a message to <code>nil</code> in Swift and Objective-C won&#39;t have any harmful effects, and is valid, but sending a message to an address in memory where an object is supposed to be but isn&#39;t will definitely cause a crash.</p></div><div class="col-sm-12"><h2 data-anchor="run-the-app" id="run-the-app"> Run the app</h2></div><div class="col-sm-12"><p> Now you&#39;re finally ready to run the Metal sample app.</p></div><div class="col-sm-12"><p> Click the <strong>Play</strong> button at the top of the Xcode window and the code will compile. If there are no errors and everything works, Xcode will launch the iOS Simulator and run the app in it:</p></div><div class="col-sm-12"><div class="align-center"> <a href="https://photos5.appleinsider.com/gallery/55525-112885-z-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112885-z-xl.jpg" alt="在 iOS 模拟器中运行的示例应用程序。" height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Sample app running in iOS Simulator.</span></div></div><div class="col-sm-12"><p> Note some, but not all, Metal code won&#39;t run in the simulator. You&#39;ll have to run those Metal programs on a real iOS device instead. </p></div><div class="col-sm-12"><h2 data-anchor="final-interface-builder-tips" id="final-interface-builder-tips"> Final Interface Builder tips</h2></div><div class="col-sm-12"><p> As one last look at the sample project, we need to go over a few items in Interface Builder.</p></div><div class="col-sm-12"><div class="align-center"><a href="https://photos5.appleinsider.com/gallery/55525-112888-Screenshot-6-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112888-Screenshot-6-xl.jpg" alt="在 Xcode 中选择 Main.storyboard 文件。" height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Select the Main.storyboard file in Xcode.</span></div></div><div class="col-sm-12"><p> If you are new to Xcode and Interface Builder, note that one critical aspect of iOS development most newcomers overlook is that of class names. The class names each item has in Xcode must match exactly each class name as defined in the source code files.</p></div><div class="col-sm-12"><p> If they don&#39;t, your app won&#39;t work.</p></div><div class="col-sm-12"><p> For example, the view controller must have its class name set in the Custom Class field in Xcode&#39;s object info panel on the right side. To do so you have to click the Storyboard or .nib (Interface Builder) file, then click the class name in the Scene or view hierarchy, then verify or set the class name in the inspector on the right:</p></div><div class="col-sm-12"><div class="align-center"><a href="https://photos5.appleinsider.com/gallery/55525-112886-Screenshot-7-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112886-Screenshot-7-xl.jpg" alt="确保在 Storyboard 文件中设置类名称。" height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Make sure class names are set in the Storyboard file.</span></div></div><div class="col-sm-12"><p> The same holds true for Views and their class names, and other objects such as delegate properties. Failure to set even one class name or property can cause an app to not work.</p></div><div class="col-sm-12"><p> Most of these usually get set in template files created by Xcode, but it doesn&#39;t hurt to check.</p></div><div class="col-sm-12"><p> One thing that oddly doesn&#39;t get set in Xcode template files are the connections between view controllers and their View properties. You have to make these connections manually or else your app won&#39;t work.</p></div><div class="col-sm-12"><p> For example in our sample project, if you Control-click on the Game View Controller object in the view hierarchy you&#39;ll notice that the View property is set to nil. You&#39;ll need to connect the View to the Game View Controller by Control-clicking and then dragging from the Game View Controller to the View in the hierarchy.</p></div><div class="col-sm-12"><p> When you do, the &quot;Outlets&quot; panel will appear and you need to connect to the &quot;view&quot; property to the Game View Controller object manually:</p></div><div class="col-sm-12"><div class="align-center"><a href="https://photos5.appleinsider.com/gallery/55525-112887-Screenshot-9-xl.jpg" target="_blank"><img src="https://photos5.appleinsider.com/gallery/55525-112887-Screenshot-9-xl.jpg" alt="通过 Outlets 窗格连接视图控制器和视图。" height="768" loading="lazy" class="img-responsive article-image" referrerpolicy="no-referrer"></a></div><div class="col-sm-12"> <span class="carousel-caption">Connect the view controller and view via the Outlets pane.</span></div></div><div class="col-sm-12"><p> Without this connection, the app won&#39;t work. And the sample template files created by Xcode <em>don&#39;t</em> make this connection for you by default.</p></div><div class="col-sm-12"><p> Note that the small dot next to outlet names in the Outlet panel indicates whether any given outlet is connected or not.</p></div><div class="col-sm-12"><p> You may have also noticed that the AppDelegate.swift file contains a subclass of <code>AppDelegate</code> which contains empty boilerplate code but there are no references to the <code>GameViewController</code> anywhere in the app delegate file.</p></div><div class="col-sm-12"><p> So how does the <code>GameViewController</code> get loaded when the app runs?</p></div><div class="col-sm-12"><p> The answer is the Storyboard file defines the initial view controller and loads it automatically for you when the app first runs. If you were using older .nib-style (Interface Builder) files and code to load the initial view controller, your app instead would have manually created and loaded a <code>GameViewController</code> object instance the AppDelegate&#39;s <code>application:didFinishLaunchingWithOptions</code> method.</p></div><div class="col-sm-12"><p> Once the view controller then loaded the view, you would get the viewDidLoad() message on the app delegate if you set the AppDelegate as the view controller&#39;s delegate.</p></div><div class="col-sm-12"><h2 data-anchor="additional-resources" id="additional-resources">其他资源</h2></div><div class="col-sm-12"><p>In addition to Apple&#39;s online MetalKit and Metal documentation, there are a number of other good Metal resources you may want to check out.</p></div><div class="col-sm-12"><p> Be sure to check out metalkit.org and metalbyexample.com which have lots of great tutorials on MetalKit and Metal itself.</p></div><div class="col-sm-12"><p> Also, be sure to get the definitive third-party book on Metal, the <a href="https://www.amazon.com/Metal-Programming-Guide-Tutorial-Reference-ebook/dp/B077Y3DGBP/?tag=reality" rel="sponsored">Metal Programming Guide: Tutorial and Reference via Swift</a> by Janie Clayton which teaches you just about everything there is to know about Metal programming.</p></div><div class="col-sm-12"><p> This has been a long tutorial, but now you should have a much greater understanding of how Metal apps work and how to use MetalKit in your apps to easily load textures and render Metal objects in views in iOS apps.</p></div><p></p> ]]>;</description><pubDate> Sun, 06 Aug 2023 20:58:13 GMT</pubDate><guid ispermalink="false"> https://appleinsider.com/inside/xcode/tips/understanding-metalkit-getting-started-with-apples-graphics-framework</guid><link/> https://appleinsider.com/inside/xcode/tips/understanding-metalkit-getting-started-with-apples-graphics-framework<author><![CDATA[Chip Loder]]></author></item></channel></rss>